## 서문(Introduction)

2019년 8월, 1년쯤 전 [Ultimate Go Study Guide](https://github.com/hoanhan101/ultimate-go) 라는 프로젝트를 GitHub 에 공유했습니다.
그리고 놀랍게도, 커뮤니티의 많은 관심을 받았으며 2020년 8월 기준 12K star, 900 fork 를 넘어섰습니다. 20 여분의 contributor 분들 덕분입니다.

프로젝트는 [Ardan Lab's Ultimate Go course](https://www.oreilly.com/library/view/ultimate-go-programming/9780134757476/) 를 공부하며
정리한 것 입니다. Bill Kennedy와 Ardan Labs team이 이처럼 멋진 코스를 오픈소스화 한 것에 한 없는 감사를 드립니다.
지식과 통찰을 코스에 녹여내고, 모두에게 나누어 준 엄청난 작업이었습니다.

사람마다 나름의 학습 방법이 있겠지만, 저는 예제를 따라해보고 실행하며 배웁니다. 신중히 노트하고, 소스코드에
바로 코멘트하여 코드 한 줄, 한 줄을 확실히 이해하고 코드 뒤에 숨어있는 이론까지 신경씁니다.

Ultimate Go Study Guide 가 성장하며 많은 분들이 이북 버전을 요청하셨습니다.
이어서 읽을 수 있고, 좀더 편하게 읽을 수 있기 때문입니다.

그래서 이렇게 The Ultimate Go Study Guide eBook version 을 만들었습니다. 지난 3개월 여
제 여유시간 대부분을 Ultimate Go Study Guide를 200 페이지의 책으로 만드는데 쏟아부었습니다.
Ultimate Go 의 모든 좋은 점에 더하여, 이북에서는 두 가지 장점이 더해졌습니다.

- code 의 input과 output을 따라가며 썼습니다.
- 다이어그램이 추가되었습니다.

이북 버전을 통해 Go 좀더 쉽게 배우셨으면 합니다. 그리고 다시 한 번, 모든 분들의 지원과 성원에 감사합니다. 정말 감사합니다.

즐겁게 읽으십시오!

## Go 언어의 역학적 고찰(Language Mechanics)

### 문법(Syntax)

#### 변수(Variable)

##### 빌트-인 타입(Built-in types)

타입은 두 가지 질문을 통해 완전성과 가독성을 제공한다

- 할당한 메모리의 크기는 얼마인가? (예. 32-bit, 64-bit)
- 이 메모리는 무엇을 의미하는가? (예. int, uint, bool, ...)

타입은 `int32`, `int64`처럼 명확한 이름도 있다. 예를 들어

- `uint8`은 1 바이트 메모리에 10진수 숫자를 가지고 있다.
- `int32`는 4 바이트 메모리에 10진수 숫자를 가지고 있다.

`uint` 나 `int` 처럼 메모리 크기가 명확하지 않은 타입을 선언하면, 아키텍처에 따라 크기가 달라진다.
64-bit OS라면, `int` 는 `int64`와 같은 크기가 되고, 32-bit OS 라면 `int32`와 같은 크기가 된다.

**워드 크기**

워드의 크기는 워드가 몇 바이트인지를 말하며, 이는 메모리 주소의 크기와 같다. 예를 들어 64 비트 아키텍처에서
워드 사이즈는 64 비트(8 바이트)이고, 메모리 주소의 크기도 64 비트이다. 따라서 `int` 는 64 비트이다.

##### 제로 값 컨셉(Zero value concept)

모든 변수는 초기화되어야 한다. 어떤 값으로 초기화할지를 명시하지 않으면, 제로 값(zero value)으로 초기화 된다.
할당하는 메모리의 모든 비트는 0으로 리셋된다.

| Type           | Zero value |
| -------------- | ---------- |
| Boolean        | false      |
| Integer        | 0          |
| Floating Point | 0          |
| Complex        | 0i         |
| String         | ""         |
| Pointer        | nil        |

##### 선언과 초기화(Declare and initialize)

`var` 로 변수를 선언하면 타입의 zero value 로 초기화된다.

```go
var a int
var b string
var c float64
var d bool
fmt.Printf("var a int \t %T [%v]\n", a, a)
fmt.Printf("var b string \t %T [%v]\n", b, b)
fmt.Printf("var c float64 \t %T [%v]\n", c, c)
fmt.Printf("var d bool \t %T [%v]\n\n", d, d)
```

```
var a int     int [0]
var b string  string []
var c float64 float64 [0]
var d bool    bool [false]
```

**문자열은 `uint8` 타입의 연속이다**

문자열은 두 개의 워드로 된 데이터 구조체이다: 첫 번째 워드는 뒤에 숨겨져 있는 배열을 가리키는 포인터이고,
두 번째 워드는 문자열의 길이이다. 문자열의 제로 값(zero value)은 첫 번째 워드는 nil, 두 번째 워드는 0이다.

짧은 변수 선언(short variable declaration) 연산자를 사용하면 선언과 동시에 초기화 할 수 있다.
(역자 주. 제로 값이 아닌 특정한 값으로 초기화 하려 할때 자주 쓴다.)

```go
aa := 10
bb := "hello" // 첫 번째 워드는 문자들의 배열을 기리키는 포인터이고, 두 번째 워드는 5이다.
cc := 3.14159
dd := true

fmt.Printf("aa := 10 \t %T [%v]\n", aa, aa)
fmt.Printf("bb := \"hello\" \t %T [%v]\n", bb, bb)
fmt.Printf("cc := 3.14159 \t %T [%v]\n", cc, cc)
fmt.Printf("dd := true \t %T [%v]\n\n", dd, dd)
```

```
aa := 10      int [10]
bb := "hello" string [hello]
cc := 3.14159 float64 [3.14159]
dd := true    bool [true]
```

##### 변환과 타입 변경(Conversion vs casting)

Go 는 `casting` 을 지원하지 않고 `conversion` 을 지원한다. 컴파일러에게 몇 바이트 더 있는 척
하기보다 실제로 메모리를 더 할당한다.

```go
aaa := int32(10)
fmt.Printf("aaa := int32(10) %T [%v]\n", aaa, aaa)
```

```
aaa := int32(10) int32 [10]
```

#### 구조체(Struct)

`example` 구조체 타입은 다른 타입의 필드들을 가진 구조체이다.

```go
type example struct {
    flag    bool
    counter int16
    pi      float32
}
```

##### 선언과 초기화(Declare and initialize)

`example` 구조체 타입의 변수를 선언하면, 구조체의 필드들은 제로 값(zero value)으로 초기화된다.

```go
var e1 exa

fmt.Printf("%+v\n", e1)
```

```
{flag:false counter:0 pi:0}
```

**`example 구조체에 할당하는 메모리의 크기는 얼마일까?**

`bool`은 1 바이트, `int16`은 2 바이트, `float32`는 4바이트이다. 모두 7바이트이지만, 실제로는 8바이트를 할당한다.
이를 이해하려면 `패딩(padding)`과 `정렬(alignment)`을 알아야 한다. 패딩 바이트는 `bool`과 `int16` 사이에 위치한다.
정렬 때문이다.

정렬(alignment): 하드웨어에게는 정렬 경계(alignment boundary)내의 메모리를 읽게 하는 것이 효율적이다.
하드웨어가 정렬 경계(alignment boundary)에 맞춰 읽게 소프트웨어에서 챙겨주는 것이 정렬이다.

**규칙 1:**

특정 값의 메모리 크기에 따라 Go 는 어떤 정렬(alignment)이 필요할지 결정한다. 모든 2 바이트 크기의 값은 2 바이트 경계를 가진다.
`bool` 값은 1 바이트라서 주소 0번지에서 시작한다. 그러면 다음 `int16`은 2번지에서 시작해야 한다. 건너뛰게 되는 1 바이트는 패딩 1 바이트가 들어간다.
만약 `int16` 이 아니라 `int32` 라면 3 바이트의 패딩이 들어간다.

**규칙 2:**

가장 큰 메모리 사이즈의 필드가 전체 구조체의 패딩을 결정한다. 가능한 패딩이 적을 수록 좋은데
그러려면 큰 필드부터 가장 작은 필드의 순서로 위치시키는 것이 좋다. `example` 구조체를 아래와 같이 정의하면
전체 구조체의 사이즈는 8 바이트를 따르게 되는데 `int64` 가 8 바이트이기 때문이다.

```go
type example struct {
    counter int64
    pi      float32
    flag    bool
}
```

`example` 타입의 변수를 선언하고 구조체 리터럴로 초기화 할 수 있다. 이때 각 라인은 콤마(,)로 끝나야 한다.

```go
e2 := example{
    flag:    true,
    counter: 10,
    pi:      3.141592,
}
fmt.Println("Flag", e2.flag)
fmt.Println("Counter", e2.counter)
fmt.Println("Pi", e2.pi)
```

```
Counter 10
Pi 3.141592
Flag true
```

익명의 타입 변수를 선언하고, 구조체 리터럴로 초기화 할 수 있다. 이 경우 익명 타입을 재사용할 수는 없다.

```go
e3 := struct {
    flag    bool
    counter int16
    pi      float32
}{
    flag:    true,
    counter: 10,
    pi:      3.141592,
}
fmt.Println("Flag", e3.flag)
fmt.Println("Counter", e3.counter)
fmt.Println("Pi", e3.pi)
```

```
Flag true
Counter 10
Pi 3.141592
```

##### Name type vs anonymous type

If we have two name type identical struct, we can't assign one to another. For
example, example1 and example2 are identical struct and we initialize var ex1
example1, var ex2 example2. Letting ex1 = ex2 is not allowed. We have to
explicitly say that ex1 = example1(ex2) by performing a conversion. However, if ex
is a value of identical anonymous struct type (like e3 above), then it is possible
to assign ex1 = ex.

두 개의 구조체의 필드가 완전히 똑같다 해도, 한 타입의 구조체 변수를 다른 타입의 구조체 변수에 대입할 수는 없다.
예를 들어 `example1`, `example2` 가 동일한 필드를 가지는 구조체 타입이고,
우리가 `var ex1 example1`, `var ex2 example2` 라고 변수를 선언하더라도 `ex1 = ex2` 라는 대입은 허용되지 않는다.
우리는 `ex1 = example1(ex2)` 라고 명시적인 변환(conversion)을 해줘야 한다.
하지만 만약 ex가, 위의 ex3 변수처럼, 동일한 구조의 익명 구조체 타입이라면 `ex1 = ex` 는 가능하다.

```go
var e4 example
e4 = e3
fmt.Printf("%+v\n", e4)
```

```
{flag:true counter:10 pi:3.141592}
```

#### Pointer

##### Everything is about pass by value

Pointers serve only 1 purpose: sharing. Pointers share values across the program
boundaries. There are several types of program boundaries. The most common one is
between function calls. We can also have a boundary between Goroutines which we
will discuss later.

When this program starts up, the runtime creates a Goroutine. Every Goroutine is a
separate path of execution that contains instructions that needed to be executed
by the machine. We can also think of Goroutines as lightweight threads. This
program has only 1 Goroutine: the main Goroutine.

Every Goroutine is given a block of memory, called the stack. The stack memory in
Go starts out at 2K. It is very small. It can change over time. Every time a
function is called, a piece of stack is used to help that function run. The
growing direction of the stack is downward.

Every function is given a stack frame, memory execution of a function. The size of
every stack frame is known at compile time. No value can be placed on a stack
unless the compiler knows its size ahead of time. If we don't know the size of
something at compile time, it has to be on the heap.

Zero value enables us to initialize every stack frame that we take. Stacks are
self cleaning. We clean our stack on the way down. Every time we make a function,
zero value initialization cleans the stack frame. We leave that memory on the way
up because we don't know if we would need that again.

##### Pass by value

Declare variable of type int with a value of 10. This value is put on a stack with
a value of 10.

```go
count := 10

// To get the address of a value, we use &.
println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

// Pass the "value of" count.
increment1(count)

// Printing out the result of count. Nothing has changed.
println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

// Pass the "address of" count. This is still considered pass by value,
// not by reference because the address itself is a value.
increment2(&count)

// Printing out the result of count. count is updated.
println("count:\tValue Of[" , count, "]\tAddr Of[", &count, "]")
```

```go
func increment1(inc int) {
    // Increment the "value of" inc.
    inc++
    println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
}

/*
increment2 declares count as a pointer variable whose value is always
an address and points to values of type int. The * here is not an
operator. It is part of the type name. Every type that is declared,
whether you declare or it is pre-declared, you get for free a pointer.
*/
func increment2(inc *int) {
    // Increment the "value of" count that the "pointer points to".
    // The * is an operator. It tells us the value of the pointer points to.
    *inc++
    println ("inc2:\tValue Of[", inc, "]\tAddr Of[", &inc, "]\tValue Points To[", *inc, "]")
}
```

```
count: Value Of[ 10 ] Addr Of[ 0xc000050738 ]
inc1:  Value Of[ 11 ] Addr Of[ 0xc000050730 ]
count: Value Of[ 10 ] Addr Of[ 0xc000050738 ]
inc2:  Value Of[ 0xc000050738 ] Addr Of[ 0xc000050748 ] Value Points To[ 11 ]
```

#### Escape analysis

stayOnStack shows how the variable does not escape. Since we know the size of the
user value at compile time, the compiler will put this on a stack frame.

```go
// user represents an user in the system.
type user struct {
    name  string
    email string
}

func stayOnStack() user {
    // In the stack frame, create a value and initialize it.
    u := user{
      name:  "Hoanh An",
      email: "hoanhan101@gmail.com",
    }

    // Return the value, pass back up to the main stack frame.
    return u
}
```

escapeToHeap shows how the variable escapes. This looks almost identical to the
stayOnStack function. It creates a value of type user and initializes it. It seems
like we are doing the same here. However, there is one subtle difference: we do
not return the value itself but the address of u. That is the value that is being
passed back up the call stack. We are using pointer semantics.

You might think about what we have after this call is: main has a pointer to a
value that is on a stack frame below. If this is the case, then we are in trouble.
Once we come back up the call stack, this memory is there but it is reusable
again. It is no longer valid. Anytime now main makes a function call, we need to
allocate the frame and initialize it.

Think about zero value for a second here. It enables us to initialize every stack
frame that we take. Stacks are self cleaning. We clean our stack on the way down.
Every time we make a function call, zero value, initialization, we are cleaning
those stack frames. We leave that memory on the way up because we don't know if we
need that again.

Back to the example. It is bad because it looks like we take the address of user
value, pass it back up to the call stack giving us a pointer which is about to get
erased. However, that is not what will happen.

What is actually going to happen is escape analysis. Because of the line "return
&u", this value cannot be put inside the stack frame for this function so we have
to put it out on the heap.

Escape analysis decides what stays on the stack and what does not. In the
stayOnStack function, because we are passing the copy of the value itself, it is
safe to keep these things on the stack. But when we SHARE something above the call
stack like this, escape analysis says this memory is no longer valid when we get
back to main, we must put it out there on the heap. main will end up having a
pointer to the heap. In fact, this allocation happens immediately on the heap.
escapeToHeap is gonna have a pointer to the heap. But u is gonna base on value
semantics.

```go
func escapeToHeap() *user {
    u := user{
        name:  "Hoanh An",
        email: "hoanhan101@gmail.com",
    }

    return &u
}
```

**What if we run out of stack space?**

What happens next is during that function call, there is a little preamble that
asks "Do we have enough stack space for this frame?". If yes then no problem
because at compile time we know the size of every frame. If not, we have to have a
bigger frame and these values need to be copied over. The memory on that stack
moves. It is a trade off. We have to take the cost of this copy because it doesn't
happen a lot. The benefit of using less memory in any Goroutine outweighs the
cost.

Because the stack can grow, no Goroutine can have a pointer to some other
Goroutine stack. There would be too much overhead for the compiler to keep track
of every pointer. The latency will be insane.

The stack for a Goroutine is only for that Goroutine. It cannot be shared between
Goroutines.

**Garbage collection**

Once something is moved to the heap, Garbage Collection has to get in. The most
important thing about the Garbage Collector (GC) is the pacing algorithm. It
determines the frequency/pace that the GC has to run in order to maintain the
smallest possible t.

Imagine a program where you have a 4 MB heap. GC is trying to maintain a live heap
of 2 MB. If the live heap grows beyond 4 MB, we have to allocate a larger heap.
The pace the GC runs at depends on how fast the heap grows in size. The slower the
pace, the less impact it is going to have. The goal is to get the live heap back
down.

When the GC is running, we have to take a performance cost so all Goroutines can
keep running concurrently. The GC also has a group of Goroutines that perform the
garbage collection work. It uses 25% of our available CPU capacity for itself.
More details about GC and pacing algorithm can be find at:
https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/ed
it?usp=sharing

#### 함수

```go
// user 구조체는 user 정보를 담고 있다.
type user struct {
    ID   int
    Name string
}

// updateStats 구조체는 업데이트 정보를 담고 있다.
type updateStats struct {
    Modified int
    Duration float64
    Success  bool
    Message  string
}

func main() {
    // user 프로필을 가져온다.
    u, err := retrieveUser("Hoanh")
    if err != nil {
        fmt.Println(err)
        return
    }

    // user 프로필을 보여준다. `u`는 주소값이기에 *를 사용하여 값을 얻어낸다.
    fmt.Printf("%+v\n" , *u)

    // user 의 name 을 업데이트 한다.
    // _(blank identifier)를 사용하여 리턴된 updateStats는 무시하기로 하며
    // if 범위 밖에서 써야할 값은 없으니 간결한 문법을 사용하였다.
    if _, err := updateUser(u); err != nil {
        fmt.Println(err)
        return
    }

    // 업데이트가 성공했다고 출력한다.
    fmt.Println("Updated user record for ID", u.ID)
}
```

`retrieveUser`는 특정한 사용자의 문서를 가져온다. 문자열 타입의 name을 넣어주면, `user` 타입을
가리키는 값과 `error` 타입의 값을 리턴한다.

```go
func retrieveUser(name string) (*user, error) {
    // getUser 함수를 호출하면 JSON 형식으로 값이 리턴된다.
    r, err := getUser(name)
    if err != nil {
        return nil, err
    }

    // JSON 값을 unmarshal하여 저장할 user 타입인 변수 u를 생성한다.
    var u user

    // 변수 u를 json.Unmarshal 함수에 전달하면, 함수는 r로부터 JSON 을 읽어서 변수 u에 넣어준다.
    err = json.Unmarshal([]byte(r), &u)

    // retrieveUser 함수를 호출한 함수에게 u값을 전달한다. 이처럼 retrieveUser 함수에서
    // 생성한 변수의 주소값을 호출한 함수에게 전달하기에 이 변수는 힙 메모리에 할당된다.
    return &u, err
}
```

`getUser`함수는 웹으로 호출하였을때 특정한 사용자에 대한 JSON 으로 응답이 돌아오는 것을 시뮬레이션 한 것이다.

```go
func getUser(name string) (string, error) {
    response := `{"ID":101, "Name":"Hoanh"}`
    return response, nil
}
```

`updateUser` 함수는 특정 사용자가 업데이트 되었다는 응답을 시뮬레이션 한 것이다.

```go
func updateUser(u *user) (*updateStats, error) {
    // response 변수는 JSON 응답을 시뮬레이션 한 것이다.
    response := `{"Modified":1, "Duration":0.005, "Success" : true, "Message": "updated"}`

    // JSON 문서를 userStats 구조체 타입의 변수로 unmarshal한다.
    var us updateStats
    if err := json.Unmarshal([]byte(response), &us); err != nil {
        return nil, err
    }

    // update 성공여부를 확인한다.
    if us.Success != true {
        return nil, errors.New(us.Message)
    }

    return &us, nil
}
```

```
{ID:101 Name:Hoanh}
Updated user record for ID 101
```

#### 상수

Constants are not variables. Constants have a parallel type system all to
themselves. The minimum precision for constant is 256 bit. They are considered to
be mathematically exact. Constants only exist at compile time.

상수는 변수가 아니며 상수를 위한 parallel type system[재방문] 이 있다.
상수의 최소 정밀도(minimum precision)는 265 bit 이며, 이 정도의 정밀도는 수학적으로 정확하다고 간주한다.
상수는 컴파일을 하는 동안만 존재한다.[재방문: 설명필요]

##### 선언과 초기화

상수는 타입이 있을 수도, 없을 수도 있다. 타입이 없을 때에는(untyped) 이를 `kind`로 간주한다.
타입이 없는 상수는 컴파일러가 암묵적으로 특정 타입으로 변환한다.

타입이 없는 상수.

```go
const ui = 12345    // kind: integer
const uf = 3.141592 // kind: floating-point
```

타입이 있는 상수는 여전히 상수 타입 시스템을 사용하지만 그 정밀도는 타입이 없는 상수에 비해
제한적이다.

```go
const ti int = 12345        // type: int
const tf float64 = 3.141592 // type: float64
```

상수 1000을 `uint8` 에 대입하려 하면 오버플로우가 발생한다.

```go
const myUint8 uint8 = 1000
```

상수는 다른 kind를 산술적으로 지원한다. Kind 승급(kind promotion)을 이용해서 어떤 `kind`
인지를 결정한다. 이 모든 것은 암묵적으로 이루어진다.

`answer` 변수는 `float64` 타입이 될 것이다.

```go
var answer = 3 * 0.333 // KindFloat(3) * KindFloat(0.333)
fmt.Println(answer)
```

```
0.999
```

Constant third will be of kind floating point.
상수 `third`의 `kind`는 실수가 될 것이다.[^type-and-kind]

```go
const third = 1 / 3.0 // KindFloat(1) / KindFloat(3.0)
fmt.Println(third)
```

```
0.3333333333333333
```

상수 0은 kind 정수이다.

```go
const zero = 1 / 3 // KindInt(1) / KindInt(3)
fmt.Println(zero)
```

```
0
```

타입이 있는 상수와 타입이 없는 상수의 산술 계산을 보자.
계산을 하려면 둘은 비슷한 타입이어야 한다. 아래 코드에서는 둘 다 정수이다.

```go
const one int8 = 1
const two = 2 * one // int8(2) * int8(1)

fmt.Println(one)
fmt.Println(two)
```

```
1
2
```

64 bit 아키텍처에서 가장 큰 정수이다.

```go
const maxInt = 9223372036854775807
fmt.Println(maxInt)
```

```
9223372036854775807
```

`bigger` 상수는 `int64` 타입보다 훨씬 큰 숫자이지만 타입이 없는 상수이기에
컴파일에 문제가 없다. (아키텍처에 따라 다르긴 하지만) 256 bit 는 정말 큰 공간이다.

```go
const bigger = 9223372036854775808543522345
```

하지만 `biggerInt` 상수는 `int64` 타입이기 때문에 컴파일 시에 에러가 난다.

```go
const biggerInt int64 = 9223372036854775808543522345
```

##### iota

```go
const (
    A1 = iota // 0 : 0에서 시작한다
    B1 = iota // 1 : 1 증가한다
    C1 = iota // 2 : 1 증가한다
)

fmt.Println("1:", A1, B1, C1)

const (
    A2 = iota // 0 : 0에서 시작한다
    B2        // 1 : 1 증가한다
    C2        // 2 : 1 증가한다
)

fmt.Println("2:", A2, B2, C2)

const (
    A3 = iota + 1 // 1 : 1에서 시작한다
    B3            // 2 : 1 증가한다
    C3            // 3 : 1 증가한다
)

fmt.Println("3:", A3, B3, C3)

const (
    Ldate= 1 << iota //  1 : 오른쪽으로 0번 시프트 된다. 0000 0001
    Ltime            //  2 : 오른쪽으로 1번 시프트 된다. 0000 0010
    Lmicroseconds    //  4 : 오른쪽으로 2번 시프트 된다. 0000 0100
    Llongfile        //  8 : 오른쪽으로 3번 시프트 된다. 0000 1000
    Lshortfile       // 16 : 오른쪽으로 4번 시프트 된다. 0001 0000
    LUTC             // 32 : 오른쪽으로 5번 시프트 된다. 0010 0000
)
fmt.Println("Log:", Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC)
```

```
1: 0 1 2
2: 0 1 2
3: 1 2 3
Log: 1 2 4 8 16 32
```

[^type-and-kind]: 변수는 다른 타입으로 대입을 할 수 없지만, `kind`는 다른 타입으로 `암묵적으로` 변환이 된다
