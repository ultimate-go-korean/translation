#### Behavior as context

Behavior as context allows us to use a custom error type as our context but avoid that type assertion back to the concrete. We get to maintain a level of decoupling in our code.

```go
package​ main
import​ (
    "bufio"
    "fmt"
    "io"
    "log"
    "net"
)
```

client represents a single connection in the room.

```go
type​ client ​struct​ {
    name ​string
    reader *bufio.Reader
}
```

TypeAsContext shows how to check multiple types of possible custom error types that can be returned from the net package.

```go
func​ (c *client) ​TypeAsContext​() {
    for​ {
```

We are using reader interface value to decouple ourselves from the network read.

```go
        line, err := c.reader.ReadString(​'\n'​)
        if​ err != ​nil​ {
```

This is using type as context like the previous example. What special here is the method named Temporary. If it is, we can keep going but if not, we have to break things down and build things back up. Every one of these cases care only about 1 thing: the behavior of Temporary. This is what important. We can switch here, from type as context to type as behavior if we do this type assertion and only ask about the potential behavior of that concrete type itself. We can go ahead and declare our own interface called temporary like below.

```go
            switch​ e := err.(​type​) {
            case​ *net.OpError:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving chat"​)
                    return
                }
            case​ *net.AddrError:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving chat"​)
                    return
                }
            case​ *net.DNSConfigError:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving return chat")
                    return
                }
            default​:
                if​ err == io.EOF {
                    log.Println(​"EOF: Client leaving chat"​)
                    return
                }
            log.Println(​"read-routine"​, err)
            }
        }
    fmt.Println(line)
    }
}
```

temporary is declared to test for the existence of the method coming from the net package. Because Temporary is the only behavior we care about. If the concrete type has the method named temporary then this is what we want. We get to stay decoupled and continue to work at the interface level.

```go
type​ temporary ​interface​ {
    Temporary() ​bool
}
```

BehaviorAsContext shows how to check for the behavior of an interface that can be returned from the net package.

```go
func​ (c *client) ​BehaviorAsContext​() {
    for​ {
        line, err := c.reader.ReadString(​'\n'​)
        if​ err != ​nil​ {
            switch​ e := err.(​type​) {
```

We can reduce 3 cases into 1 by asking in the case here during type assertion:
Does the concrete type stored inside the error interface also implement this interface. We can declare and leverage that interface ourselves.

```go
            case​ temporary:
                if​ !e.Temporary() {
                    log.Println(​"Temporary: Client leaving return chat")
                    return
                }
            default​:
                if​ err == io.EOF {
                    log.Println(​"EOF: Client leaving chat"​)
                    return
                }
                log.Println(​"read-routine"​, err)
            }
        }
        fmt.Println(line)
    }
}
```

**Lesson:**

Thank to Go Implicit Conversion. We can maintain a level of decoupling by creating an interface with methods or behaviors that we only want, and use it instead of concrete type for type assertion switch.

#### Finding the bug

```go
package​ main
import​ ​"log"
```

customError is just an empty struct.

```go
type​ customError ​struct​{}
```

Error implements the error interface.

```go
func​ (c *customError) ​Error​() ​string​ {
    return​ ​"Find the bug."
}
```

fail returns nil values for both return types.

```go
func​ ​fail​() ([]​byte​, *customError) {
    return​ ​nil​, ​nil
}
```

```go
func​ ​main​() {
    var​ err error
```

When we call fail, it returns the value of nil. However, we have the nil value of type \*customError. We always want to use the error interface as the return value. The customError type is just an artifact, a value that we store inside. We cannot use the custom type directly. We must use the error interface, like so func fail() ([]byte, error)

```go
    if​ _, err = fail(); err != ​nil​ {
        log.Fatal(​"Why did this fail?"​)
    }
    log.Println(​"No Error"​)
}
```

#### Wrapping Errors

Error handling has to be part of our code and usually it is bound to logging. The main goal of logging is to debug. We only log things that are actionable. Only log the contexts that are allowed us to identify what is going on. Anything else ideally is noise and would be better suited up on the dashboard through metrics. For example, socket connection and disconnection, we can log these but these are not actionable because we don't necessarily lookup the log for that.

There is a package that is written by Dave Cheney called errors that let us simplify error handling and logging at the same time. Below is a demonstration on how to leverage the package to simplify our code. By reducing logging, we also reduce a large amount of pressure on the heap (garbage collection).

```go
import (
    "fmt"

    "github.com/pkg/errors"
)
```

AppError represents a custom error type.

```go
type​ AppError ​struct​ {
    State ​int
}
```

AppError implements the error interface.

```go
func​ (c *AppError) ​Error​() ​string​ {
    return​ fmt.Sprintf(​"App Error, State: %d"​, c.State)
}
```

```go
func​ ​main​() {
```

Make the function call and validate the error. firstCall calls secondCall calls thirdCall then results in AppError. Start down the call stack, in thirdCall, where the error occurs. This is the root of the error. We return it up the call stack in our traditional error interface value.

Back to secondCall, we get the interface value and there is a concrete type stored inside the value. secondCall has to make a decision whether to handle the error and push up the call stack if it cannot handle. If secondCall decides to handle the error, it has the responsibility of logging it. If not, its responsibility is to move it up. However, if we are going to push it up the call stack, we cannot lose context. This is where the error package comes in. We create a new interface value that wraps this error, add a context around it and push it up. This maintains the call stack of where we are in the code.

Similarly, firstCall doesn't handle the error but wraps and pushes it up. In main, we are handling the call, which means the error stops here and we have to log it.

In order to properly handle this error, we need to know that the root cause of this error was. It is the original error that is not wrapped. Cause method will bubble up this error out of these wrapping and allow us to be able to use all the language mechanics we have.

We are not only able to access the State even though we've done this assertion back to concrete, we can log out the entire stack trace by using %+v for this call.

Use type as context to determine cause. We got our custom error type.

```go
    if​ err := firstCall(​10​); err != ​nil​ {
        switch​ v := errors.Cause(err).(​type​) {
        case​ *AppError:
            fmt.Println(​"Custom App Error:"​, v.State)
```

Display the stack trace for the error.

```go
            fmt.Println(​"\nStack Trace\n********************************"​)
            fmt.Printf(​"%+v\n"​, err)
            fmt.Println(​"\nNo Trace\n********************************"​)
            fmt.Printf(​"%v\n"​, err)
        }
    }
}
```

firstCall makes a call to a secondCall function and wraps any error.

```go
func​ ​firstCall​(i ​int​) ​error​ {
    if​ err := secondCall(i); err != ​nil​ {
        return​ errors.Wrapf(err, ​"firstCall->secondCall(%d)"​, i)
    }
    return​ ​nil
}
```

secondCall makes a call to a thirdCall function and wraps any error.

```go
func​ ​secondCall​(i ​int​) ​error​ {
    if​ err := thirdCall(); err != ​nil​ {
        return​ errors.Wrap(err, ​"secondCall->thirdCall()"​)
    }
    return​ ​nil
}
```

thirdCall function creates an error value we will validate.

```go
func​ ​thirdCall​() ​error​ {
    return​ &AppError{​99​}
}
```

```
Custom App Error: 99
Stack Trace
********************************
App Error, State: 99
secondCall->thirdCall()
main.secondCall
    /tmp/sandbox880380539/prog.go:74
main.firstCall
    /tmp/sandbox880380539/prog.go:65
main.main
    /tmp/sandbox880380539/prog.go:43
runtime.main
    /usr/local/go-faketime/src/runtime/proc.go:203
runtime.goexit
    /usr/local/go-faketime/src/runtime/asm_amd64.s:1373
firstCall->secondCall(10)
main.firstCall
    /tmp/sandbox880380539/prog.go:66
main.main
    /tmp/sandbox880380539/prog.go:43
runtime.main
    /usr/local/go-faketime/src/runtime/proc.go:203
runtime.goexit
    /usr/local/go-faketime/src/runtime/asm_amd64.s:1373

No Trace
********************************
firstCall->secondCall(10): secondCall->thirdCall(): App Error, State: 99
```
