### Patterns

#### Context

##### Store and retrieve values from a context

Context package is the answer to cancellation and deadline in Go.

```go
package main

import (
    "context"
    "fmt"
)
```

`user` is the type of value to store in the context.

```go
type user struct {
    name string
}
```

`userKey` is the type of value to user for the key.
The key is type of specific and only values of the same type will match.
When we store a value inside a context,
what getting stored is not just a value but also a type associated with the storage.
We can only pull a value out of that context if we know the type of value that we are looking for.
The idea of this `userKey` type becomes really important when we want to store a value inside the context.

```go
type userKey int

func main()
```

Create a value of type `user`.

```go
    u := user {
        name: "Hoanh",
    }
```

Declare a key with the value of zero of type

```go
    const uk userKey = 0
```

Store the pointer to the user value inside the context with a value of zero of type `userKey`.
We are using `context.WithValue` because a new context value and we want to initialise that with data to begin with.
Anytime we work a context, the context has to have a parent context.
This is where the `Background` function comes in.
We are gonna store the key `uk` to its value (which is `0` in this case),
and address of user.

```go
    ctx := context.WithValue(context.Background(), uk, &u)
```

Retrieve that user `user` pointer back by `user` the same key type value.
Value allows us to pass the key of the corrected type (in our case is `uk` of `userKey` type)
and returns an empty interface.
Because we are working with an interface, we have to perform a type assertion to pull the value
that we store in there out the interface so we can work with the concrete again.

```go
    if u, ok := ctx.Value(uk).(*user); ok {
        fmt.Println("User", u.name) // note(tangoenskai): original script has typo, I did `s/u.nam/u.name`
    }
```

Attempt to retrieve the value again using the same value but of a different type.
Even though the key value is `0`, if we just pass `0` into this function call,
we are not going to get back that address to the user because `0` is based on integer type,
not our `userKey` type.

It is important that when we store the value inside the context not to user the built-in type.

Declare our own key type.
That way, only us and who understand that type can pull that out.
Because what if multiple partial programs want to user that value of `0`,
we are all being tripped up on each other.
That type extends an extra level of protection of being able to store and retrieve value out of context.
If we are using this,
we want to raise a flag because we have to ask twice why we want to do that instead of passing down the call stack.
Because if we can pass it down the call stack,
it would be much better for readability and maintainability for our legacy code in the future.

```go
    if _, ok := ctx.Value(0).(*user); !ok {
        fmt.Println("User Not Found")
    }
```

```terminal
User Hoanh
User Not Found
```

##### WithCancel

Different ways we can do cancellation, timeout in Go.

```go
package main

import (
    "context"
    "fmt"
    "fime"
)

func main() {
```

Create a context that is cancellable only manually.
The cancel function must be called regardless of the outcome.
`WithCancel` allows us to create a context and provides us a `cancel` function
that can be called in order to report a signal,
a signal without data, that we want to whatever that Goroutine is doing to stop right away.
Again, we are using `Background` as our parents context.

```go
    ctx, cancel := context.WithCancel(context.Background())
```

The cancel function must be called regardless of the outcome.
The Goroutine that creates the context must always call `cancel`.
These are things that have to be cleaned up.
It's the responsibility that the Goroutine creates the context the first time
to make sure to call `cancel` after everything is done.
The use of the `defer` keyword is prefect here for this use case.

```go
    defer cancel()
```

We launch a Goroutine to do some work for us.
It is going to sleep for 50 milliseconds and then call `cancel`.
It is reporting that it wants to signal a `cancel` without data.

```go
    go func() {
```

Simulate work.
If we run the program using 50ms, we expect the work to be complete.
But if it is 150ms, then we move on.

```go
        time.Sleep(50 * time.Millisecond)
```

Report the work is done.

```go
        cancel()
    }()
```

The original Goroutine that creates that channel is in its select case.
It is going to receive after `time.After`.
We are going to wait 100 milliseconds for something to happen.
We are also waiting on `context.Done`.
We are just going to sit here, and if we are told to `Done`,
we know that work up there is complete.

```go
    select {
    case <-time.After(100 * time.Millisecond):
        fmt.Println("moving on")
    case <-ctx.Done():
        fmt.Println("work complete")
    }
}
```

```terminal
work complete
```

##### WithDeadline

```go
package main

import (
    "context"
    "fmt"
    "time"
)

type data struct {
    UserID string
}

func main() {
```

Set a deadline.

```go
    deadline := time.Now().Add(150 * time.Millisecond)
```

Create a context that is both manually cancellable and will signal a cencel at the specified data/time.
We use `Background` as our parents context and set out deadline time.

```go
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
```

Create a channel to received a signal that work is done.

```go
   ch := make(chan data, 1)
```

Ask a Goroutine to do some work for us.

```go
    go func() {
```

Simulate work.

```go
        time.Sleep(200 * time.Millisecond)
```

Report the work is done.

```go
        ch <- data{"123"}
    }()
```

Wait for the work to finish.
If it takes too long move on.

```go
    select {
    case d := <-ch:
        fmt.Println("work complete", d)
    case <-ctx.Done():
        fmt.Println("work cancelled")

    }
}
```

```terminal
work cancelled
```

##### WithTimeout 169

```go
package main

import (
    "context"
    "fmt"
    "time"
)

type data struct {
    UserID string
}

func main (){
```

Set a duration

```go
    duration := 150 * time.Millisecond
```

Create a context that is both manually cancellable and will signal a cancel at the specified duration.

```go
    ctx, cancel := context.WithTimeout(context.Background(), duration)
    defer cancel()
```

Create a channel to received a signal that work is done.

```go
    ch := make(chan data, 1)
```

Ask the goroutine to do some work for us,

```go
    go func() {
```

Simulate work.

```go
        time.Sleep(50 * time.Millisecond)
```

Report the work is done.

```go
        ch <- data{"123"}
    }()
```

Wait for the work to finish.
If it takes too long, move on.

```go
    select {
    case d := <-ch:
        fmt.Println("work complete", d)
    case <-ctx.Done():
        fmt.Println("work cancelled")
    }
}
```

```terminal
work complete {123}
```

##### Request/Response 171
