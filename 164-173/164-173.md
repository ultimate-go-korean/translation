### Patterns

#### Context

##### Store and retrieve values from a context

`context` 패키지는 Go 에서 취소(cancellation)와 데드라인(deadline)에 대한 해답(answer)이다.

```go
package main

import (
    "context"
    "fmt"
)
```

`user` 는 context 내에 값을 저장하기 위한 타입이다.

```go
type user struct {
    name string
}
```

`userKey`는 `user`의 값에 대한 키(key) 타입이다.
키는 하나의 타입이고, 동일한 타입의 값만 매치할 수 있다.
context 내에서 값을 저장하려고 할 때,
실제로 저장되는 것은 값 뿐만이 아니라 그 값에 연관된 타입도 포함한다.
우리가 찾는 값의 타입을 알고 있는 경우에만 해당하는 context 내에서 값을 추출해 낼 수 있다.
`userKey` 타입과 같은 아이디어는 context 내부에 값을 저장하고 싶을 떄 상당히 중요하다.

```go
type userKey int

func main()
```

`user` 타입에 대한 값 생성한다.

```go
    u := user {
        name: "Hoanh",
    }
```

키를 해당 타입의 제로값과 함꼐 선언한다.

```go
    const uk userKey = 0
```

context에 `user` 값의 포인터 그리고 `userKey` 타입의 제로값을 저장하라.
새로운 `context` 값을 생성하기 위해서 `context.WithValue` 함수를 사용하며, 미리 준비한 데이터를 바탕으로 초기화를 하고자 한다.
context를 가지고 작업을 할 때마다 context에는 상위 context(parent context)가 있어야 한다.
그래서, `Background` 함수를 도입한다.
키인 `uk`를 그 키의 값(여기서는 `0`에 해당함) 그리고 `user`의 주소(address)를 저장 할 것이다.

```go
    ctx := context.WithValue(context.Background(), uk, &u)
```

키 타입 값과 동일한 `user`포인터의 값을 검색 해 보자.
`Value`는 올바른 타입(the corrected type)을 전달할 수 있게 해 주고 (이 경우에 `userKey` 타입의 `uk`),
빈 인터페이스(an empty interface)를 반환한다.

인터페이스를 사용하고 있기 때문에, 저장된 값을 꺼내오기 위해 type assertion을 수행해야 한다.

```go
    if u, ok := ctx.Value(uk).(*user); ok {
        fmt.Println("User", u.name)
    }
```

다른 타입을 가지고 위의 값을 검색해보려고 시도해 보자.
비록 키의 실제 값이 `0`이지만, 이 함수 호출에 `0`을 전달한다 해도
원하고자 하는 `user`의 주소를 얻을 수 없을 것이다.
왜냐하면 `0`은 정수(integer)기반으로 하는 타입이지,
우리가 정의한 `userKey`타입 기반이 아니기 때문이다.

context에 값을 저장 할 떄, built-in 타입을 사용하지 않는 것이 중요하다.

사용자 정의의 키 타입을 사용하자.
그러면 이 타입에 대해서 인지하고 있을 경우에만 context에서 그 값을 꺼내 올 수 있다.
만약, 여러 프로그램이 숫자 `0` 키값을 사용해 `user`를 추출한다면,
모든 것이 엉망이 되어버릴 수 있다.
이런 타입이 context에 값을 저장 및 추출할 수 있도록 추가적인 보호해준다.
우리가 이런 기법을 사용하면, 콜 스택(call stack)을 전달하는 대신
왜 이런 방법으로 하려고 하는지 두 번 확인해야 하기 때문에 플래그를 사용하고 싶을 것이다.
콜 스택으로 이를 전달할 수 있다면, 향후에 레거시 코드의 가독성과 유지관리에 훨씬 더 유리할 것이다.

```go
    if _, ok := ctx.Value(0).(*user); !ok {
        fmt.Println("User Not Found")
    }
```

```terminal
User Hoanh
User Not Found
```

##### WithCancel

Different ways we can do cancellation, timeout in Go.

```go
package main

import (
    "context"
    "fmt"
    "fime"
)

func main() {
```

Create a context that is cancellable only manually.
The cancel function must be called regardless of the outcome.
`WithCancel` allows us to create a context and provides us a `cancel` function
that can be called in order to report a signal,
a signal without data, that we want to whatever that Goroutine is doing to stop right away.
Again, we are using `Background` as our parents context.

```go
    ctx, cancel := context.WithCancel(context.Background())
```

The cancel function must be called regardless of the outcome.
The Goroutine that creates the context must always call `cancel`.
These are things that have to be cleaned up.
It's the responsibility that the Goroutine creates the context the first time
to make sure to call `cancel` after everything is done.
The use of the `defer` keyword is prefect here for this use case.

```go
    defer cancel()
```

We launch a Goroutine to do some work for us.
It is going to sleep for 50 milliseconds and then call `cancel`.
It is reporting that it wants to signal a `cancel` without data.

```go
    go func() {
```

Simulate work.
If we run the program using 50ms, we expect the work to be complete.
But if it is 150ms, then we move on.

```go
        time.Sleep(50 * time.Millisecond)
```

Report the work is done.

```go
        cancel()
    }()
```

The original Goroutine that creates that channel is in its select case.
It is going to receive after `time.After`.
We are going to wait 100 milliseconds for something to happen.
We are also waiting on `context.Done`.
We are just going to sit here, and if we are told to `Done`,
we know that work up there is complete.

```go
    select {
    case <-time.After(100 * time.Millisecond):
        fmt.Println("moving on")
    case <-ctx.Done():
        fmt.Println("work complete")
    }
}
```

```terminal
work complete
```

##### WithDeadline

```go
package main

import (
    "context"
    "fmt"
    "time"
)

type data struct {
    UserID string
}

func main() {
```

Set a deadline.

```go
    deadline := time.Now().Add(150 * time.Millisecond)
```

Create a context that is both manually cancellable and will signal a cencel at the specified data/time.
We use `Background` as our parents context and set out deadline time.

```go
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
```

Create a channel to received a signal that work is done.

```go
   ch := make(chan data, 1)
```

Ask a Goroutine to do some work for us.

```go
    go func() {
```

Simulate work.

```go
        time.Sleep(200 * time.Millisecond)
```

Report the work is done.

```go
        ch <- data{"123"}
    }()
```

Wait for the work to finish.
If it takes too long move on.

```go
    select {
    case d := <-ch:
        fmt.Println("work complete", d)
    case <-ctx.Done():
        fmt.Println("work cancelled")

    }
}
```

```terminal
work cancelled
```

##### WithTimeout 169

```go
package main

import (
    "context"
    "fmt"
    "time"
)

type data struct {
    UserID string
}

func main (){
```

Set a duration

```go
    duration := 150 * time.Millisecond
```

Create a context that is both manually cancellable and will signal a cancel at the specified duration.

```go
    ctx, cancel := context.WithTimeout(context.Background(), duration)
    defer cancel()
```

Create a channel to received a signal that work is done.

```go
    ch := make(chan data, 1)
```

Ask the goroutine to do some work for us,

```go
    go func() {
```

Simulate work.

```go
        time.Sleep(50 * time.Millisecond)
```

Report the work is done.

```go
        ch <- data{"123"}
    }()
```

Wait for the work to finish.
If it takes too long, move on.

```go
    select {
    case d := <-ch:
        fmt.Println("work complete", d)
    case <-ctx.Done():
        fmt.Println("work cancelled")
    }
}
```

```terminal
work complete {123}
```

##### Request/Response 171

Sample program that implements a web request with a context
that is used to timeout the request if it takes too long.

```go
package main

import (
    "context"
    "io"
    "log"
    "net"
    "net/http"
    "os"
    "time"
)

func main() {
```

Create a new request

```go
    req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
    if err != nil {
        log.Println(err)
        return
    }
```

Create a context with a timeout of 50 milliseconds.

```go
    ctx, cancel := context.WithTimeout(req.Context(), 50 * time.Millisecond)
    defer cancel()
```

Declare a new transport and client for the call.

```go
    tr := http.Transport {
        Proxy: http.ProxyFromEnvironment,
        DialContext: (&net.DialerP{
            Timeout:   30 * time.Second,
            Timeout:   30 * time.Second,
            DualStack: true,
        }).DialContext,
        MaxIdleConns:          100,
        IdleConnTimeout:       90 * time.Second,
        TLSHandshakeTimeout:   10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
    }
    client := http.Client{
        Transport: &tr,
    }
```

Make the web call in a separate Goroutine so it can be cancelled.

```go
    ch := make(chan error, 1)
    go func() {
        log.Println("Starting Request")
```

Make the web call and return any `error.client.Do` is going out and trying to hit the request URL.
It's probably blocked right now because it will need to wait for the entire document to come back.

```go
        resp, err := client.Do(req)
```

If the error occurs, we perform a send on the channel to report that we are done.
We are going to use this channel at some point to report back what is happening.

```go
        if err != nil {
            ch <- err
            return
        }
```

If it doesn't fail, we close the response body on the return.

```go
        defer resp.Body.Close()
```

Write the response to `stdout`.

```go
        io.Copy(os.Stdout, resp.Body)
```

Then, send back the `nil` instead of `error`.

```go
        ch <- nil
    }()
```

Wait the request or timeout.
We perform a receive on `ctx.Done()` saying that we want to wait 50 ms for that whole process above to happen.
If it doesn't, we signal back to that Goroutine to cancel the sending request.
We don't have to just walk away and let that eat up resources and finish because we are not going to need it.
We are able to call `CancelRequest` and underneath, we are able to kill that connection.

```go
    select {
    case <-ctx.Done():
        log.Println("timeout, cancel work...")
        tr.CancelRequest(req)
        log.Println(<-ch)
    case err := <-ch:
        if err != nil {
            log.Println(err)
        }
    }
}
```

```terminal
2020/08/24 18:37:18 Starting Request
2020/08/24 18:37:18 timeout, cancel work...
2020/08/24 18:37:18 Get https://wwww.ardanlabs.com/blog/post/index.xml:
net/http: request canceled while waiting for connection
```
