## 동시성

### Mechanics [재방문: 다른 번역자분들과 의견 맞추기]

#### 고루틴(Goroutine)

##### Go 스케줄러 내부

Go로 제작된 프로그램이 시작될때 사용 가능한 코어수를 확인합니다. 그리고 논리 프로세서를 생성 합니다.

운영체제 스케줄러는 선점형 스케줄러로 간주되며, 이는 커널에서 실행 됩니다. 그 역할은 실행 가능한 상태에 있는 모든 스레드를 살펴보고 일부 코어에서 실행할 수 있는 기회를 제공 하는 것입니다. 이러한 알고리즘은 상당히 복잡합니다(대기, 스레드 바운싱, 스레드 메모리 유지, 캐싱등). 이 모든 작업을 운영체제가 수행 하며 이를 위한 알고리즘은 멀티 코어 프로세서에서 영리합니다.[재방문: 잘 처리 한다]. Go는 바퀴를 재발명 하지 않기 위하여 운영체제의 최상단에 위치 하여, 이를 활용 합니다.

운영 체제는 여전히 운영 체제 스레드를 담당하고 이를 효율적으로 스케쥴링합니다. 2개의 코어 머신에서 수천게의 쓰레드가 동작하는 것은 꽤 큰 작업입니다[재방문]. 일부 운영체제에서는 컨텍스트 스위칭 대상 쓰레드가 어떤 작업을 수행 하는지에 대한 정보[재방문: 단서]가 없어 해당 작업에 비용이 상딩히 큽니다.

컨텍스트 스위칭시 가능한 쓰레드의 모든 상태를 저장해야 그 상태를 그대로 복원 할 수 있습니다. 스레드 수가 적을 경우 각 스레드별로 더 많은 실행 시간[재방문: 스케쥴될 기회]을 가질 수 있습니다. 스레드가 더 많으면 각 스레드는 오랜 기간 동안 대기 되며, 더 적은 실행 시간을 갖습니다.

컨커런트 소프트웨어[재방문: 저절한 번역문이 무엇일까]에서는 "과유불급[재방문: 적은 것으로 많은 것을 하는것]"이 정말 중요한 컨셉 입니다. Go의 스케쥴러는 선점형 스케쥴러의 이점을 활용하기 위하여, 어플리케이션이 동작하는 중 논리 프로세서는 사용자 모드(user mode)에서 실행 됩니다. 이런 이유로 Go의 스케줄러를 협력 스케줄러라고 불러야합니다. 여기서 주목할 점은 실행시간(runtime)을 조정하는 작업 입니다. 이것은 여전히 사용자 영역에서는 선점 형 스케줄러로 보입니다. "적은 것이 더 많다"라는 개념이 어떻게 나타나고 적은 비용으로 더 많은 작업을 수행 할 수 있는지 살펴볼 것입니다. 우리의 목표는 더 적은 수의 스레드로 얼마나 많은 작업을 수행하는지가 되어야 합니다.

하이퍼쓰레딩, 코어당 다수의 쓰레드,클록 주기들의 개념은 복잡하기 때문에, 이를 간단하게 다음과 같이 생각해 봅시다. 주어진 코어당 한번에 하나의 운영 체제 스레드만 실행 할 수 있습니다. 만약 하나의 코어만 있다면, 한번에 하나의 스레드만을 실행 할 수 있습니다. 실행 가능한 상태의 스레드가 소유한 코어보다 더 많으면 항상 부하, 실행 지연이 발생 하고, 우리가 원하는 것보다 더 많은 작업을 수행 하게 됩니다. 모든 스레드가 반드시 동시에 활성화되는 것은 아니기 때문에 이러한 작업은 균형을 잡는 것이 필요 합니다. 이러한 모든 것은 우리가 작성하고 있는 소프트웨어의 작업량을 알아내고, 이해하는 것으로 귀결된다. 첫 번째 아이디어로 돌아가서, Go 프로그램이 시작되면(comes up) 사용 가능한 코어수를 확인 해야 합니다. 이를 1개 라고 합시다. 그러면 해당 코어에 논리 프로세스 P가 생성 됩니다.

다시 말하지만, 운영체제는 운영체제 스레드를 중심으로 스케쥴링 합니다. m은 머신[재방문: 코어]을 나타내며, 프로세서 P는 m(머신)을 할당받고 이는 운영체제 시스템 쓰레드이며, 운영체제가 이를 스케쥴하고, 코드가 실행 될 수 있도록 합니다.

Linux 스케쥴러에는 실행 대기열이 있습니다. 스레드는 특정 코어 또는 코어 제품군의 실행 대기열에 배치되며 스레드가 실행될 때 지속적으로 바인딩됩니다. Go도 동일한 작업을 수행 합니다. Go에는 실행 대기열도 있습니다. GRQ (Global Run Queue)가 있고 모든 P에는 LRQ (Local Run Queue)가 있습니다.

##### 고루틴

고루틴은 실행 경로 이며, 스레드 또한 실행 경로 입니다. 실행 경로는 스케쥴링이 필요합니다. Go에서는 모든 함수와 메소드는 고루틴으로 생성 될 수 있으며, 이들은 모두 코어에 할당되는[재방문] 운영체제 시스템 스레드를 통해 스케쥴링 되는 독립적인 실행 경로를 가질 수 있다. [재방문: 즉 고루틴이 시스템 스레드를 통해 실행 된다는 말인것 같은데... 말로 표현하기 힘드내..] 

Go 프로그램을 시작할 때 런타임에서 가장 먼저 할 일은 고루틴을 만들고 일부 P에 대한 주요 LRQ에 넣는 것입니다. 우리의 경우에는 여기에 P가 1 개만 있으므로 고루틴이 P에 연결되어 있다고 생각할 수 있습니다.

고루틴은 스레드와 같이 세가지(슬립, 실행중, 실행 가능)상태 중 하나일 수 있습니다. 실행시간에 고루틴이 생성되면, P에 위치(할당?)되고, 해당 스레드에서 다중화[재방문: 동시 실행] 됩니다. 스레드를 스케쥴링하고 코어에 배치하고 실행 하는 것은 운영체제라는 것을 기억하세요. 따라서 Go 스케줄러는 해당 고루틴의 실행 경로와 관련된 모든 코드를 가져 와서 스레드에 배치하고 운영 체제가 대상 스레드가 실행 가능한 상태이며 실행할 수 있음을 알려줍니다. 대답이 예이면 운영 체제가 하드웨어의 일부 코어에서 실행되기 시작합니다.

매인 고루틴이 실행 중에는 추가 실행 경로나, 고루틴을 생성 하려 할 수 있습니다.

그 시점에 해당 고루틴은 처음에는 자신을 GRQ에서 찾을 수 있습니다. 이들은 실행 가능한 상태에 있지만, 아직 P에 할당되지 않은 고루틴입니다. 결국 그들은 LRQ에 할당되고, 실행 시간을 요청 하게 됩니다.

이 대기열은 선입선출(FIFO) 규칙을 무조건 따르진 않습니다. 여기에있는 모든것[재방문]이 운영체제 스케줄러처럼 비 결정적이라는 것을 이해 해야 합니다. 모든 조건[재방문: 것]이 동일할 때 스케줄러가 무엇을 수행할지 예측할 수 없습니다. 우리가 이러한 고루틴의 실행에 대한 조정하는 방법을 배워 오케스트레이션[재방문]을 할 수 있을 때 까지는 예측이 불가능 합니다.

아래의 도표는 이에 대한 예제를 표현한 맨탈모델[재방문]입니다.

![117-1](../diagrams/117-1.jpg)

프로세서 `P`에 `m`을 위한 `Gm`이 실행하고, 2개의 `G1`과 `G2` 고루틴을 생성한다. 이것은 협조적 스케쥴러(cooperating scheduler)이기에, 고루틴은 스케줄링 되기 위해 협력(cooperate)하고 운영체제 스레드인 `m`은 문맥교환(context switch)이 생기는 것을 의미한다.

스케줄러가 스케줄링을 하게 되는 4가지 상황이 있다.[재방문]

- `go` 키워드를 통해 고루틴들을 생성할 때. 이는 여러개의 프로세서(P)를 가지고 있을 때, 스케줄러가 균형을 다시 맞출 수 있다.
- 시스템 콜. 시스템 콜은 이미 항상 발생 하는 경향이 있다.
- 뮤텍스(Mutex)를 사용하는 채널. (추후 학습)
- 가비지 컬렉션.

다시 예제로 돌아와, 스케줄러는 `Gm`이 실행하기에 충분한 시간이 있을때, `Gm`을 실행 대기열(run queue)에 넣고 `G1`이 해당 `m`에서 실행되도록 혀용한다(문맥교환).

![117-2](../diagrams/117-2.jpg)

`G1`이 파일을 연다고 해보자. 파일을 여는 것은 짧은 시간이 걸릴지, 오래 걸릴지, 그것을 알 수가 없다. 만약 파일을 열 때 이 고루틴(`G1`)이 OS 스레드를 블록(block) 시킨다면, 더 이상의 다른 작업을 완료할 수가 없다. 이 예제는 하나의 프로세서(`P`)와 싱글 스레드(`m`)로 동작하는 어플리케이션이다. 모든 고루틴은 프로세서(`P`)에 할당된 스레드(`m`)에서만 동작한다. 만약 고루틴이 프로세서(`P`)에 할당된 스레드(`m`)을 오랫동안 블록(block)시킨다면 어떻게 될까? 작업이 완료될 때까지 아무것도 할 수 없다. 이런일이 발생하지 않도록 하기 위해 스케줄러는 `m`과 `G1`을 분리한다. 새로운 `m`인 `m2`를 가져오고, 실행 대기열(run queue)에서 다음에 실행할 `G`, 즉 `G2`를 결정한다.

![118-1](../diagrams/118.jpg)

이제 싱글 스레드로 작성된 프로그램에 2개의 스레드가 있다. 우리의 관점에서 여전히 싱글 스레드 인데, 모든 고루틴과 관련된 코드는 프로세서(`P`)와 OS 스레드(`m`)에 대해서만 실행할 수 있기 때문이다. 하지만 어떤 `m`이 처리되고 있는지 알 수는 없다. 스레드(`M`)은 교체될 수 있고, 여전히 싱글 스레드로 이다.

`G1`이 파일 열기 작업을 끝냈을 때, 스케줄러는 `G1`을 실행 대기열(run queue)에 넣고나서 특정 스레드, 예제에서는 `m2`를 다시 실행할 수 있다. `m`은 다시 사용하기 위해 남겨지고, 여전히 2개의 스레드를 유지하고 있다. 전체 과정은 다시 일어날 수 있다.

![119-1](../diagrams/119-1.jpg)

이것은 하나의 스레드에서 더 많은 작업을 수행하고, 이 스레드를 최대한 활용하는 멋진 방법이다. 하나의 스레드로 많은 작업을 할 수 있다. 추가 스레드는 필요가 없다.[재방문: 의역 확인]

여기 네트워크 풀러가 있고, 모든 로우 레벨(low level)의 비동기 네트워킹 작업을 수행한다. 고루틴은 이러한 작업을 수행할 경우, 네트워크 풀러로 이동한 다음 다시 되돌아 올 수 있다. 여전히 명심할 것은 작성된 코드는 프로세서(`P`)에서 수행할 스레드(`m`)가 처리된다는 것이다. 프로세서(`P`)를 얼마나 가지고 있는지, 그리고 스레드(`m`)에 의해 실행된다.[재방문: 의역]

동시성이란 이런 많은 작업들을 한번에 관리할 수 있는 것을 의미하고, 이것이 스케줄러의 역할이다. 하나의 OS 스레드(`m`)에 의해 3개의 고루틴은 오직 한번에 1개의 고루틴만 실행될 수 있기에, 하나의 프로세서(`P`), 하나의 스레드(`m`) 그리고 3개의 고루틴을 관리하는 것을 의미한다.
만약 한번에 많은 일들을 동시에 처리하고 싶다면, 다시 말해서 병렬(parallel)처리하고 싶다면 또 다른 스레드(`m3`)를 처리할 수 있는 프로세서(`P`)가 하나 더 필요하다. 

![119-2](../diagrams/119-2.jpg)

멀티 프로세서는 OS에 의해 스케줄링 된다. 이제 2개의 고루틴을 병렬(parallel)로 처리할 수 있다.

다중 스레드로 처리될 수 있는 소프트웨어가 있다고 가정해보자. 이제 2개의 고루틴을 병렬(parallel)로 처리할 수 있다. 프로그램은 2개의 스레드를 실행하고, 두 스레드가 동일한 코어에 있는 경우에도 서로에게 메세지를 전달하려고 한다. OS의 관점에서는 어떤 일이 일어나는지 알아보자.

먼저 첫번째 스레드가 스케줄링 되고 특정 코어에 지정[재방문: core에 place on을 어떻게 해석할지]될 때까지 기다려야 한다(문맥교환 발생). 이때, 아직 스레드는 대기 상태이므로 어떤 것도 실행 상태가 아니다. 첫번째 스레드에서 메세지를 보내고, 이에 대한 응답을 받기를 기다린다. 응답을 받기 위해서, 해당 코어에 다른 스레드를 배치할 수 있고 이를 통해서 또 다른 문맥교환이 발생한다. OS가 두번째 스레드를 스케줄링하기를 기다리며 또 다른 문맥교환이 발생한다. sleep 상태의 스레드를 실행시켜[재방문: sleep 상태의 thread를 wake up 하는 적절한 번역] 메세지를 처리한다. 메세지 전달 과정을 통해, 스레드는 `excutable state`에서 `runnable state`로 전환되며 `asleep state` 상태로 바뀐다. 이러한 문맥교환들은 많은 비용(`cost`)이 발생한다[재방문: 의미 번역 CS 참고].

단일 코어에서 고루틴을 사용하면 어떤지 살펴보자. `G1`은 `G2`에게 메세지를 보내려 하고 문맥 교환이 일어난다. 하지만 이 문맥(`context`)은 사용자의 공간 전환이다.[재방문] 스레드의 `G1`을 `G2`로 전환할 수 있다. OS의 관점에서 이 스레드는 `sleep` 상태가 되지 않는다. 이 스레드는 항상 실행중이며, 문맥교환을 할 필요가 없다. Go 스케줄러는 고루틴을 계속해서 문맥교환 시켜준다.[재방문]

프로세서(`P`)에 대해, 스레드(`m`)이 수행할 작업이 없고, 어떠한 고루틴(`G`)도 없다면 런타임 스케줄러는 약간의 작업을 수행할 수 있다[재방문]. 왜냐하면, 스레드가 수행할 작업이 없다면 OS는 해당 스레드를 코어에서 빼내고 다른 작업을 수행하기 때문이다. 따라서 작업을 수행할 고루틴(`G`)이 있는지 확인한다.

이것이 스케줄러가 작동하는 방식이다. 프로세서(`P`)와 스레드(`m`)이 있고, OS는 스케줄링 작업을 할 것이다. 코어의 갯수보다 더 많은 것을 필요로 하지 않는데, 코어의 갯수보다 더 많은 OS 스레드가 필요하지 않다. 코어의 갯수보다 더 많은 스레드가 있다는 것은 OS에 적재하는 방법 뿐인데, Go의 스케줄러는 고루틴에 대해 최소한으로 필요한 스레드 수를 유지하고 작업을 계속해서 수행할 수 있도록 한다. Go의 스케줄러는 협력적인 스케줄링으로 호출되더라도 선점된 것처럼 보인다.

하지만 개발을 쉽게 하기 위해서 스케줄링의 작동에 대해 잊고, 모든 고루틴(`G`)에 대해 `runnable state`에 있는 고루틴들은 모두 동시에 실행이 가능하다고 이해하자.

#### Language Mechanics [재방문: 다른 번역자분들과 의견 맞추기]

소프트웨어가 깔끔하게 시작, 종료되도록 코드를 작성하는 것은 매우 중요하다.

```go
package​ main

import​ (
    "fmt"
    "runtime"
    "sync"
)
```

초기화 요청(init call)[재방문: 용어]으로 런타임 패키지에서 `GOMAXPROCS`을 호출한다. 환경 변수이기 때문에 대문자로 표기된다.

Go 1.5 이전에서는 코어 수의 관계 없이 하나의 프로세서(`P`)만 제공 되었다. 가비지 콜렉터와 스케줄러의 개선으로 모든것이 개선되었다.

스케줄러에게 하나의 논리 프로세서만 할당할 것을 명시한다.


```go
func​ ​init​() {
    runtime.GOMAXPROCS(​1​)
}

func​ ​main​() {
```

`wg`는 동시성을 관리하는데 사용된다. `wg`는 제로값으로 설정된다. 또한 제로값 상태에서 사용할 수 있는 Go의 매우 특별한 타입이다. 그리고 비동기 계산 세마포어(Asynchronous Counting Semaphore)로 불린다. 

세개의 `Add`, `Done`, `Wait` 메소드를 갖는다. n개의 고루틴은 이 메소드를 동시에 호출 할 수 있고, 모두 직렬화(serialized)되어 있다.

- `Add`: 얼마나 많은 고루틴이 있는지 계산한다.
- `Done`: 일부 고루틴이 종료될 예정이므로 값을 감소시킨다.
-  `Wait`: 해당 카운트가 0이 될 때까지 프로그램을 유지한다.

```go
    var​ wg sync.WaitGroup
```

2개의 고루틴을 생성하자. 반대로 Add(1)을 호출하고, 1씩 증가하기 위해 반복한다. 만약 얼마나 많은 고루틴이 생성될지 모른다면, 그것은 코드 스멜(smell)이다.

```go
    wg.Add(​2​)

    fmt.Println(​"Start Goroutines"​)
```

익명함수를 사용해 `uppercase` 함수에서 고루틴을 생성한다. 익명함수의 끝에는 `()`을 사용해 호출한다. `main` 함수 내부에 익명함수가 있고, 그 앞에 `go` 키워드에 주목하자. 지금은 실행하지 않고, Go 스케줄러는 해당 함수를 G로 예약한다. 이를 G1이라고 하자. 그리고 `P`에 대해 일부 `LRQ`를 로드한다. 이것이 첫 `G`이다. 기억할것은, 모든 `G`에 대해서 `runnable state`라면, 동시에 실행할 수 있다. 싱글 프로세서(`P`)일지라도, 싱글 스레드일지라도 전혀 상관없다. 2개의 고루틴을 동시에 실행(`main` 그리고 `G1`)한다.

```go
    go​ ​func​() {
        lowercase()
        wg.Done()
    }()
```

`lowercase` 이후에 고루틴을 하나 더 생성한다. 따라서, 이제는 3개의 고루틴이 동시에 실행된다.

```go
go func() {
    uppercase()
    wg.Done()
}()
```

고루틴이 끝날때까지 기다려보자. 메인이 종료되는 것을 대기(holding)시키는데, 메인이 종료될 때, 우리의 프로그램은 종료되고, 다른 고루틴을 신경쓰지 않기 때문이다.

여기서 중요한 것은 언제, 어떻게 고루틴이 종료되는지 모른다면 고루틴을 만들 수도 없다는 것이다. `Wait`는 두 개의 고루틴이 `Done`이 될때까지 대기(hold)하도록 한다. `2`에서 `0`이 될 때까지 카운트하고, `0`에 도달했을 때, 스케줄러는 메인 고루틴을 마저 실행하고, 종료 될 수 있도록 한다.

```go
    fmt.Println(​"Waiting To Finish"​) wg.Wait()
    wg.Wait()

    fmt.Println(​"\nTerminating Program"​)
}
```

`lowercase` 함수는 알파벳 소문자를 세번 반복 출력한다.

```go
func​ ​lowercase​() {
    for​ count := ​0​; count < ​3​; count++ {
        for​ r := ​'a'​; r <= ​'z'​; r++ {
            fmt.Printf(​"%c "​, r)
        }
    }
}
```

`lowercase` 함수는 알파벳 대문자를 세번 반복 출력한다.

```go
func​ ​uppercase​() {
    for​ count := ​0​; count < ​3​; count++ {
        for​ r := ​'A'​; r <= ​'Z'​; r++ {
            fmt.Printf(​"%c "​, r)
        }
    }
}
```

```
Start Goroutines
Waiting To Finish
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J
K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T
U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d
e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n
o p q r s t u v w x y z
Terminating Program
```

##### 순서

`lowercase` 함수를 호출하고, `uppercase` 함수를 호출했지만, Go 스케줄러는 `lowercase` 함수를 먼저 호출했다. 싱글 스레드에서 동작하기에 순간에 1개의 고루틴만 실행할 수 있는 점을 기억하자. 동시성을 지키며 실행되는지 알 수 없는데, `uppercase` 함수가 `lowercase` 함수보다 먼저 실행되는지 알 수 없다. 시작, 종료에 문제가 없다.

대기를 위해 `Wait`하지 않으면 어떻게 될까?

`uppercase` 함수와 `lowercase` 함수의 결과를 볼 수 없다. 이것은 경쟁 상태인데, It's a race to see the program terminate before the scheduler stops it and schedules another Goroutine to run. 기다리지 않기 때문에 고루틴은 실행할 기회가 전혀 없다.

`Done`을 호출하지 않으면 어떻게 될까?

교착상태(Deadlock)가 발생한다. Go의 특별한 부분이며, 런타임에서 고루틴이 존재하지만 더 이상 진행할 수 없을 때 패닉(panic)상태가 된다.

##### 고루틴 시분할(time slicing)

Go의 스케줄러는 선점 스케줄러(preemptive)가 아닌 협력 스케줄러(cooperating scheduler)에도 선점된 것처럼 생각되는 이유는 런타임 스케줄러가 모든 처리를 하기 때문이다[재방문].

아래의 코드는 문맥교환을 보여주고, 언제 문맥교환이 발생하는지 예상할 수 있도록 보여준다. 위 코드와 같은 패턴이지만 `printPrime` 함수가 새로 추가된다.

```go
package​ main

import​ (
    "fmt"
    "runtime"
    "sync"
)
```

하나의 논리 프로세서를 스케줄러에게 할당한다.

```go
func init() {
    runtime.GOMAXPROCS(1)
}
```

`wg`는 동시성을 관리하기 위해 사용한다.

```go
func​ ​main​() {
    var​ wg sync.WaitGroup
    wg.Add(​2​)

    fmt.Println(​"Create Goroutines"​)
```

첫번째 고루틴을 생성하고, 생명주기를 관리한다.

```go
    go​ ​func​() {
        printPrime(​"A"​)
        wg.Done()
    }()
```

두번째 고루틴을 생성하고, 생명주기를 관리한다.


```go
    go​ ​func​() {
        printPrime(​"B"​)
        wg.Done()
    }()
```

고루틴이 종료될 때까지 대기한다.

```go
    fmt.Println(​"Waiting To Finish"​)
    wg.Wait()

    fmt.Println(​"Terminating Program"​)
}
```

`printPrime` 함수는 5000보다 작은 소수를 출력한다. 특별한 함수는 아니지만, 완료하기 위해 약간의 시간이 필요하다. 프로그램을 실행하면 특정 소수에서 문맥교환이 일어나는 것을 볼 수 있다. 하지만 문맥교환이 언제 일어날 지는 예측할 수 없기에 Go의 스케줄러가 협력 스케줄러임에도 불구하고 선점 스케줄러처럼 보인다고 말하는 이유이다.

```go
func​ ​printPrime​(prefix ​string​) {
next:
    for​ outer := ​2​; outer < ​5000​; outer++ {
        for​ inner := ​2​; inner < outer; inner++ {
            if​ outer%inner == ​0​ {
                continue​ next
            }
        }

        fmt.Printf(​"%s:%d\n"​, prefix, outer)
    }

    fmt.Println(​"Completed"​, prefix)
}
```

```
Create Goroutines
Waiting To Finish
B:2
B:3
B:5
B:7
B:11
B:13
B:17
B:19
...
B:4999
Completed B
A:2
A:3
A:5
A:7
A:11
A:13
A:17
A:19
...
A:4999
Completed A
Terminating Program
```

##### 고루틴과 병렬

이 프로그램은 고루틴이 병렬처리 되는 것을 보여준다. 2개의 프로세서(`P`), 2개의 스레드(`m`) 그리고 2개의 고루틴이 각각의 스레드(`m`)에서 병렬 처리 된다. 이전 프로그램과 비슷하지만 `lowercase` 함수와 `uppercase` 함수를 없애고, 익명 함수로 처리한다.

```go
package​ main
import​ (
    "fmt"
    "runtime"
    "sync"
)

func​ ​init​() {
```

스케줄러에게 2개의 논리 프로세서를 할당한다.

```go
    runtime.GOMAXPROCS(​2​)
}

func​ ​main​() {
```

`wg`는 프로그램이 종료될때까지 기다리는데 사용한다. `Add`에 2를 추가함으로, 2개의 고루틴을 대기한다[재방문: 의역 확인].

```go
    var​ wg sync.WaitGroup
    wg.Add(​2​)

    fmt.Println(​"Start Goroutines"​)
```

소문자 알파벳을 3번 출력하는 익명 함수를 선언하고, 고루틴을 생성한다. 

```go
    go​ ​func​() {
        for​ count := ​0​; count < ​3​; count++ {
            for​ r := ​'a'​; r <= ​'z'​; r++ {
                fmt.Printf(​"%c "​, r)
            }
        }
        wg.Done() //메인(main)에게 작업이 끝났음을 알린다.
    }
```

대문자 알파벳을 3번 출력하는 익명 함수를 선언하고, 고루틴을 생성한다. 

```go
    go​ ​func​() {
        for​ count := ​0​; count < ​3​; count++ {
            for​ r := ​'A'​; r <= ​'Z'​; r++ {
                fmt.Printf(​"%c "​, r)
            }
        }
        wg.Done() //메인(main)에게 작업이 끝났음을 알린다.
    }()
```


고루틴이 끝나기를 기다린다.

```go
    fmt.Println(​"Waiting To Finish"​)
    wg.Wait()

    fmt.Println(​"\nTerminating Program"​)
}
```

소문자와 대문자가 섞여서 출력되는 것을 확인할 수 있다.

```
Start Goroutines
Waiting To Finish
a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j
k l m n o p A B C D E F G H I J K L M N O P Q R S q r s t u v w x y z a
b c d e f g h i j k l m n o p q r s t u v w x y z T U V W X Y Z A B C D
E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N
O P Q R S T U V W X Y Z
Terminating Program
```
