#### 변환(Conversion)

##### 인터페이스 변환

`Mover`는 움직이는 것을 나타내기 위해 다음과 같이 정의합니다.

```go
type Mover interface {
    Move()
}
```

`Locker`는 잠그고(locking) 해제(unlocking)할 수 있는 것을 나타냅니다.

```go
type Locker interface {
    Lock()
    Unlock()
}
```

`MoveLocker`는 움직이거나 잠글 수 있는 것을 나타냅니다.

```go
type MoveLocker interface {
    Mover
    Locker
}
```

구체적인 예시를 위해 `bike`라는 타입을 정의합니다.

```go
type bike struct {}
```

`Move`는 `bike`를 움직입니다.

```go
func (bike) Move() {
    fmt.Println("Moving the bike")
}
```

`Lock`은 `bike`가 움직이지 못하게 합니다.

```go
func (bike) Lock() {
    fmt.Println("Locking the bike")
}
```

`Unlock`을 하면 `bike`는 다시 움직일 수 있습니다.

```go
func (bike) Unlock() {
    fmt.Println("Unlocking the bike")
}

func main() {
```

`MoverLocker`와 `Mover` 인터페이스 타입의 변수를 선언합니다. zero value로 초기화 됩니다.

```go
    var ml MoveLocker
    var m Mover
```

`bike` 값을 생성하여 `MoveLocker` 인터페이스 타입 변수에 대입합니다.

```go
    ml = bike{}
```

`MoveLocker` 인터페이스 타입 변수는 `Mover` 인터페이스 타입 변수로 변환할 수 있습니다. 둘 모두 `move`라는 메쏘드를 정의했기 때문입니다.

```go
    m = ml
```

![`MoveLocker`에서  `Mover`로 암묵적 변환](../diagrams/91.jpg)

하지만, 아래와 같이 반대로는 불가능합니다.

```go
    ml = m
```

컴파일을 하면 다음과 같은 에러가 발생합니다.

```
cannot use m (type Mover) as type MoveLocker in assignment:
Mover does not implement MoveLocker (missing Lock method).
```

##### 타입 단언(Type assertion)

인터페이스 타입 `Mover`는 `lock`과 `unlock` 메서드를 정의하고 있지 않다. 따라서, 컴파일러는 인터페이스 `Mover` 타입의 변수를 `MoveLocker` 타입의 변수로 암묵적으로 변환할 수 없다. `Mover` 인터페이스 변수의 실제 값이 `MoveLocker` 인터페이스를 구현한 `bike` 타입의 값이라 해도 변환하지 않는다. 런타임때 타입 단언을 사용하여 명시적으로 변환할 수는 있다.

아래와 같이 `Mover` 인터페이스의 값을 타입 단언을 사용해 `bike` 타입의 값으로 변환 후 복사한다. 복사된 값을 `MoveLocker` 인터페이스 변수에 배정한다. 아래 코드가 타입 단언의 문법이다. 인터페이스 값에 `인터페이스값.(bike)`처럼 점(.)에 파라미터로 `bike` 값을 전달한다. `m` 이 `nil`이 아닌 `bike` 타입의 값이 들어있을 경우, 포인터가 아닌 값 시맨틱을 사용하고 있기 때문에 복사된 값을 얻게 된다. 그렇지 않을 경우 `panic`이 발생하게 된다. 아래 예시에서 `b`는 `bike`의 복사된 값을 가지고 있다.

```go
    b := m.(bike)
```

타입 단언의 성공 여부를 나타내는 `boolean` 값을 받아 `panic`을 예방 할 수도 있다.

```go
    b, ok := m.(bike)
    fmt.Println("Does m has value of bike?:", ok)

    ml = b
```

```
Does m has value of bike?: true
```

타입 단언의 문법을 통해 인터페이스 변수에 실제 저장된 값의 타입이 무엇인지 알 수 있다. 캐스팅을 사용하는 다른 언어에 비해 가독성 관점에서 큰 장점이라고 할 수 있다.

##### 런타임 타입 단언

```go
package main
import (
    "fmt"
    "math/rand"
    "time"
)
```

`car`는 무엇가 운전할 수 있는 것을 의미한다.

```go
type car struct{}
```

`String`은 `fmt.Stringer` 인터페이스를 구현한다.

```go
func (car) String() string {
    return "Vroom!"
}
```

`cloud`는 정보를 저장해 둘 장소를 의미한다.

```go
type cloud struct{}
```

`String`은 마찬가지로 `fmt.Stringer` 인터페이스를 구현한다.

```go
func (cloud) String() string {
    return "Big Data!"
}
```

랜덤 함수에 사용될 `Seed`값을 정한다.

```go
func main() {
    rand.Seed(time.Now().UnixNano())
```

`Stringer` 인터페이스를 가지는 슬라이스를 생성한다.

```go
    mvs := []fmt.Stringer{
        car{},
        cloud{},
    }
```

아래와 같은 코드를 10번 반복해보자. 

```go
    for i := 0; i < 10; i++ {
        rn := rand.Intn(2)
```

아래와 같이 랜덤으로 생성된 숫자를 통해 `cloud`에 대한 타입 단언을 실행한다. 아래 예시는 타입 단언이 컴파일 때가 아닌 런타임때 실행된다는 것을 알 수 있다.

```go
        if v, ok := mvs[rn].(cloud); ok {
            fmt.Println("Got Lucky:", v)
            continue
        }
```

`x`라는 변수가 있으면 `x.(T)`를 통해 `T` 타입으로 단언 될 수 있는지 확인해줘야 한 . 아니면 무결성 문제로 `panic`하길 원할 경우라면 `ok` 변수를 사용하지 않을 것이다. `panic`으로부터 회복할 수 없으면 프로그램은 바로 종료 될 것이고 100% 무결성을 유지할 수 있을 것이다. 다.

프로그램이 종료된다는 의미는 스택 트레이스가 출력되는 `log.Fatal`, `os.exit` 혹은 `panic` 함수를 호출했다는 것이다. 타입 단언을 사용할 때는, 요청하는 타입의 값이 들어있지 않아도 괜찮은지 확인해야 한다.

타입 단언을 사용해 구체적인 타입의 값을 꺼낼 경우, 적신호가 울려야 한다. 디커플링의 레벨을 유지하기 위해 인터페이스를 사용했는데 타입 단언을 사용해 다시 이전으로 돌아가기 때문이다.

구체적인 타입을 사용할 경우 연관 있는 많은 코드를 동시에 리팩토링을 해야 될 수도 있다는 것을 알아야 한다. 반대로 인터페이스를 사용할 경우 내부 구현이 변해도 그로 인해 발생하는 변경점들은 최소화 할 수 있다.

```go
        fmt.Println("Got Unlucky")
    }
}
```

```
Got Unlucky
Got Unlucky
Got Lucky: Big Data!
Got Unlucky
Got Lucky: Big Data!
Got Lucky: Big Data!
Got Unlucky
Got Lucky: Big Data!
Got Unlucky
Got Unlucky
```

#### Interface Pollution

It comes from the fact that people are designing software from the interface
first down instead of concrete type up. So, why are we using an interface
here?

**Myth #1:** We are using interfaces because we have to use interfaces.

Answer: No. We don't have to use interfaces. We use it when it is practical and
reasonable to do so.

Even though they are wonderful, there is a cost of using interfaces: a level of
indirection and potential allocation when we store concrete type inside of
them. Unless the cost of that is worth whatever decoupling we are getting, we
shouldn't be using interfaces.

**Myth #2:**  We need to be able to test our code so we need to use interfaces.

Answer: No. We must design our API that is usable for user application
developer first, not our test.

Below is an example that creates interface pollution by improperly using an
interface when one is not needed.

Server defines a contract for TCP servers. This is a little bit of a smell
because this is some sort of APIs that is going to be exposed to users and
already that is a lot of behaviors brought in a generic interface.

```go
type Server interface {
    Start() error
    Stop() error
    Wait() error
}
```

`server` is our Server implementation. They match the name. However, that is not
necessarily bad.

```go
type server struct {
    host string
}
```

`NewServer` returns an interface value of type Server with a server
implementation. Here is the factory function. It immediately starts to smell
even worse. It is returning the interface value.

It is not that functions and interfaces cannot return interface values. They
can. But normally, that should raise a flag. The concrete type is the data that
has the behavior and the interface normally should be used as accepting the
input to the data, not necessarily going out.

SMELL - Storing an unexported type pointer in the interface.

```go
func NewServer(host string) Server {
    return &server{host}
}
```

Start allows the server to begin to accept requests. From now, let's pretend
there is a specific implementation for each of these methods.

```go
func (s *server) Start() error {
    return nil
}
```

Stop shuts the server down.

```go
func (s *server) Stop() error {
    return nil
}
```

Wait prevents the server from accepting new connections.

```go
func (s *server) Wait() error {
    return nil
}
```

```go
func main() {
```

Create a new `Server`.

```go
    srv := NewServer("localhost")
```

Use the API.

```go
    srv.Start()
    srv.Stop()
    srv.Wait()
}
```

This code here couldn't care less nor would it change if `srv` was the concrete
type, not the interface. The interface is not providing any level of support
whatsoever. There is no decoupling here that is happening. It is not giving us
anything special here. All is doing is causing us another level of indirection.

It smells because:

- The package declares an interface that matches the entire API of its own
  concrete type.
- The interface is exported but the concrete type is unexported.
- The factory function returns the interface value with the unexported concrete
  type value inside.
- The interface can be removed and nothing changes for the user of the API.
- The interface is not decoupling the API from change.

##### Remove Interface Pollution

We’re going to remove the improper interface usage from the previous program.

`Server` implementation.

```go
type Server struct {
    host string
}
```

`NewServer` returns just a concrete pointer of type `Server`

```go
func NewServer(host string) *Server {
    return &Server{host}
}
```

`Start` allows the server to begin to accept requests.

```go
func (s *Server) Start() error {         
    return nil
}
```

`Stop` shuts the server down.

```go
func (s *Server) Stop() error {
    return nil
}
```

`Wait` prevents the server from accepting new connections.

```go
func (s *Server) Wait() error {
    return nil
}
```

Create a new `Server`.

```go
func main() {
    srv := NewServer("localhost")
```

Use the APIs.

```go
    srv.Start()
    srv.Stop()
    srv.Wait()
}
```

**Guidelines around interface pollution:**

Use an interface:

- When users of the API need to provide an implementation detail.
- When APIs have multiple implementations that need to be maintained.
- When parts of the APIs that can change have been identified and require decoupling.

Question an interface:

- When its only purpose is for writing testable APIs (write usable APIs first).
- When it's not providing support for the API to decouple from change.
- When it's not clear how the interface makes the code better.

#### Mocking

##### Package To Mock

It is important to mock things. Most things over the network can be mocked in
our test. However, mocking our database is a different story because it is too
complex. This is where Docker can come in and simplify our code by allowing us
to launch our database while running our tests and have that clean database for
everything we do.

Every API only needs to focus on its test. We no longer have to worry about the
application user or user over API test. We used to worry about: if we don't
have that interface, the user who uses our API can't write tests. That is gone.
The example below will demonstrate the reason.

Imagine we are working at a company that decides to incorporate Go as a part of
its stack. They have their internal pubsub system that all applications are
supposed to use. Maybe they are doing event sourcing and there is a single
pubsub platform they are using that is not going to be replaced. They need the
pubsub API for Go that they can start building services that connect into this
event source.

So what can change? Can the event source change?

If the answer is no, then it immediately tells us that we don't need to use
interfaces. We can build the entire API in the concrete, which we would do
first anyway. We then write tests to make sure everything works.

A couple days later, they come to us with a problem. They have to write tests
and they cannot hit the pubsub system directly when my test runs so they need
to mock that out. They want us to give them an interface. However, we don't
need an interface because our API doesn't need an interface. They need an
interface, not us. They need to decouple from the pubsub system, not us.

They can do any decoupling they want because this is Go. The next file will be
an example of their application. Package pubsub simulates a package that
provides publication/subscription type services.

```go
package  main

import  (
    "fmt"
)
```

`PubSub` provides access to a queue system.

```go
type PubSub struct {
    host string
}
```

New creates a pubsub value for use.

```go
func New(host string) *PubSub {
    ps := PubSub{
        host: host,
    }

    return  &ps
}
```

Publish sends the data to the specified key.

```go
func (ps *PubSub) Publish(key string, v interface{}) error {
    fmt.Println("Actual PubSub: Publish")
    return nil
}
```

Subscribe sets up a request to receive messages from the specified key.

```go
func (ps *PubSub) Subscribe(key string) error {
    fmt.Println("Actual PubSub: Subscribe")
    return nil
}
```

##### Client

Sample program to show how we can personally mock concrete types when we need
to for our own packages or tests.

```go
package  main

import  (
    "fmt"
)
```

`publisher` is an interface to allow this package to mock the pubsub package.
When we are writing our applications, declare our own interface that maps out
all the APIs calls we need for the APIs. The concrete types APIs in the
previous files satisfy it out of the box. We can write the entire application
with mocking decoupling from concrete implementations.

```go
type publisher interface {
    Publish(key string, v interface{}) error
    Subscribe(key string) error
}
```

`mock` is a concrete type to help support the mocking of the pubsub package.

```go
type mock struct{}
```

`Publish` implements the `publisher` interface for the mock.

```go
func (m *mock) Publish(key string, v interface{}) error {
    // ADD YOUR MOCK FOR THE PUBLISH CALL.
    fmt.Println("Mock PubSub: Publish")
    return nil
}
```

`Subscribe` implements the `publisher` interface for the mock.

```go
func  (m *mock) Subscribe(key string) error {
    // ADD YOUR MOCK FOR THE SUBSCRIBE CALL.
    fmt.Println("Mock PubSub: Subscribe")
    return nil
}
```

Create a slice of `publisher` interface values. Assign the address of a pubsub.
`PubSub` value and the address of a mock value.

```go
func main() {
    pubs := []publisher{
        New("localhost"),
        &mock{},
    }
```

Range over the interface value to see how the publisher interface provides the
level of decoupling the user needs. The `pubsub` package did not need to provide
the interface type.

```go
    for _, p := range pubs {
        p.Publish("key", "value")
        p.Subscribe("key")
    }
}
```
