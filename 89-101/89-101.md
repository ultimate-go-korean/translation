#### 변환(Conversion)

##### 인터페이스 변환

`Mover`는 움직이는 것을 나타내기 위해 다음과 같이 정의합니다.

```go
type Mover interface {
    Move()
}
```

`Locker`는 잠그고(locking) 해제(unlocking)할 수 있는 것을 나타냅니다.

```go
type Locker interface {
    Lock()
    Unlock()
}
```

`MoveLocker`는 움직이거나 잠글 수 있는 것을 나타냅니다.

```go
type MoveLocker interface {
    Mover
    Locker
}
```

구체적인 예시를 위해 `bike`라는 타입을 정의합니다.

```go
type bike struct {}
```

`Move`는 `bike`를 움직입니다.

```go
func (bike) Move() {
    fmt.Println("Moving the bike")
}
```

`Lock`은 `bike`가 움직이지 못하게 합니다.

```go
func (bike) Lock() {
    fmt.Println("Locking the bike")
}
```

`Unlock`을 하면 `bike`는 다시 움직일 수 있습니다.

```go
func (bike) Unlock() {
    fmt.Println("Unlocking the bike")
}

func main() {
```

`MoverLocker`와 `Mover` 인터페이스 타입의 변수를 선언합니다. zero value로 초기화 됩니다.

```go
    var ml MoveLocker
    var m Mover
```

`bike` 값을 생성하여 `MoveLocker` 인터페이스 타입 변수에 대입합니다.

```go
    ml = bike{}
```

`MoveLocker` 인터페이스 타입 변수는 `Mover` 인터페이스 타입 변수로 변환할 수 있습니다. 둘 모두 `move`라는 메쏘드를 정의했기 때문입니다.

```go
    m = ml
```

![`MoveLocker`에서  `Mover`로 암묵적 변환](../diagrams/91.jpg)

하지만, 아래와 같이 반대로는 불가능합니다.

```go
    ml = m
```

컴파일을 하면 다음과 같은 에러가 발생합니다.

```
cannot use m (type Mover) as type MoveLocker in assignment:
Mover does not implement MoveLocker (missing Lock method).
```

##### 타입 단언(Type assertion)

인터페이스 타입 `Mover`는 `lock`과 `unlock` 메서드를 정의하고 있지 않다. 따라서, 컴파일러는 인터페이스 `Mover` 타입의 변수를 `MoveLocker` 타입의 변수로 암묵적으로 변환할 수 없다. `Mover` 인터페이스 변수의 실제 값이 `MoveLocker` 인터페이스를 구현한 `bike` 타입의 값이라 해도 변환하지 않는다. 런타임때 타입 단언을 사용하여 명시적으로 변환할 수는 있다.

아래와 같이 `Mover` 인터페이스의 값을 타입 단언을 사용해 `bike` 타입의 값으로 변환 후 복사한다. 복사된 값을 `MoveLocker` 인터페이스 변수에 배정한다. 아래 코드가 타입 단언의 문법이다. 인터페이스 값에 `인터페이스값.(bike)`처럼 점(.)에 파라미터로 `bike` 값을 전달한다. `m` 이 `nil`이 아닌 `bike` 타입의 값이 들어있을 경우, 포인터가 아닌 값을 넘겨받았기(value semantics) 때문에 `m`을 복사한 값을 얻게 된다. 그렇지 않을 경우 `panic`이 발생하게 된다. 아래 예시에서 `b`는 `bike`의 복사된 값을 가지고 있다.

```go
    b := m.(bike)
```

타입 단언의 성공 여부를 나타내는 `boolean` 값을 받아 `panic`을 예방 할 수도 있다.

```go
    b, ok := m.(bike)
    fmt.Println("Does m has value of bike?:", ok)

    ml = b
```

```
Does m has value of bike?: true
```

타입 단언의 문법을 통해 인터페이스 변수에 실제 저장된 값의 타입이 무엇인지 알 수 있다. 캐스팅을 사용하는 다른 언어에 비해 가독성 관점에서 큰 장점이라고 할 수 있다.

##### 런타임 타입 단언

```go
package main
import (
    "fmt"
    "math/rand"
    "time"
)
```

`car`는 무엇가 운전할 수 있는 것을 의미한다.

```go
type car struct{}
```

`String`은 `fmt.Stringer` 인터페이스를 구현한다.

```go
func (car) String() string {
    return "Vroom!"
}
```

`cloud`는 정보를 저장해 둘 장소를 의미한다.

```go
type cloud struct{}
```

`String`은 마찬가지로 `fmt.Stringer` 인터페이스를 구현한다.

```go
func (cloud) String() string {
    return "Big Data!"
}
```

랜덤 함수에 사용될 `Seed`값을 정한다.

```go
func main() {
    rand.Seed(time.Now().UnixNano())
```

`Stringer` 인터페이스를 가지는 슬라이스를 생성한다.

```go
    mvs := []fmt.Stringer{
        car{},
        cloud{},
    }
```

아래와 같은 코드를 10번 반복해보자.

```go
    for i := 0; i < 10; i++ {
        rn := rand.Intn(2)
```

아래와 같이 랜덤으로 생성된 숫자를 통해 `cloud`에 대한 타입 단언을 실행한다. 아래 예시는 타입 단언이 컴파일 때가 아닌 런타임때 실행된다는 것을 알 수 있다.

```go
        if v, ok := mvs[rn].(cloud); ok {
            fmt.Println("Got Lucky:", v)
            continue
        }
```

`x`라는 변수가 있으면 `x.(T)`를 통해 `T` 타입으로 단언 될 수 있는지 확인해줘야 한다. 아니면 무결성 등의 이유로 `panic`하길 원할 경우라면 `ok` 변수를 사용하지 않을 것이다. `panic`으로부터 회복할 수 없으면 프로그램은 종료될 것이고 재시작해야 한다.

프로그램이 종료된다는 의미는 스택 트레이스가 출력되는 `log.Fatal`, `os.exit` 혹은 `panic` 함수를 호출했다는 것이다. 타입 단언을 사용할 때는, 요청하는 타입의 값이 들어있지 않아도 괜찮은지 확인해야 한다.

타입 단언을 사용해 구체적인 타입의 값을 꺼낼 경우, 주의해서 사용한다. 디커플링의 레벨을 유지하기 위해 인터페이스를 사용했는데 타입 단언을 사용해 다시 이전으로 돌아가기 때문이다.

구체적인 타입을 사용할 경우 연관 있는 많은 코드를 동시에 리팩토링을 해야 될 수도 있다는 것을 알아야 한다. 반대로 인터페이스를 사용할 경우 내부 구현이 변해도 그로 인해 발생하는 변경점들은 최소화 할 수 있다.

```go
        fmt.Println("Got Unlucky")
    }
}
```

```
Got Unlucky
Got Unlucky
Got Lucky: Big Data!
Got Unlucky
Got Lucky: Big Data!
Got Lucky: Big Data!
Got Unlucky
Got Lucky: Big Data!
Got Unlucky
Got Unlucky
```

#### 인터페이스 오염(Interface Pollution)

소프트웨어를 설계할 때, 구체적인 타입이 아닌 인터페이스부터 설계를 합니다. 인터페이스를 사용하는 이유는 무엇일까요?

**미신 #1:** 인터페이스를 사용해야하기 때문에 인터페이스를 사용하고 있습니다.

답: 아니요. 인터페이스를 사용할 필요가 없습니다. 합리적이고 실용적일 때 인터페이스를 사용해야 합니다.

인터페이스를 사용하는 데는 비용이 듭니다. 구체적인 타입을 인터페이스 타입으로 사용 될때 잠재적 할당 비용과 추상화 비용입니다. 디커플링에 그만한 비용의 가치가 없다면 인터페이스를 사용해서는 안됩니다.

**미신 #2:** 코드를 테스트 하기 위해 인터페이스를 사용해야 합니다.

답: 아니요.테스트가 아니라 개발자를 우선하여 애플리케이션에 사용할 수 있는 API를 설계해야합니다.

다음은 필요하지 않은 인터페이스를 사용하여 인터페이스 오염을 생성하는 예입니다.

`Server`는 TCP 서버에 대한 계약을 정의합니다. 이것은 약간의 코드 악취에 해당하는데
이것은 사용자에게 노출 될 API이고 하나의 인터페이스에 넣기에 많은 동작입니다.

```go
type Server interface {
    Start() error
    Stop() error
    Wait() error
}
```

`server`는 `Server` 인터페이스를 구현합니다. 이름이 일치하지만 꼭 나쁘다고 할 수 는 없습니다.

```go
type server struct {
    host string
}
```

`NewServer`는 인터페이스 `Server` 타입을 리턴하는 팩토리 함수입니다. 인터페이스를 반환함으로 코드스멜로 볼 수 있습니다.

함수나 인터페이스가 인터페이스 값을 반환하지 못하는 건 아닙니다. 반환해도 됩니다. 하지만, 일반적으로 이는 주의해야 합니다. 구체적인 타입이 동작을 가지고 있는 데이터이며 인터페이스는 그런 데이터를 받는 인풋으로써 사용되어야 합니다.

코드 악취 - Export 되지 않은 타입 포인터를 인터페이스에 저장함

```go
func NewServer(host string) Server {
    return &server{host}
}
```

`Start` 는 서버를 시작해 요청을 받기 시작합니다. 여기서는 실제 구현이 되있다고 가정하겠습니다.

```go
func (s *server) Start() error {
    return nil
}
```

`Stop`은 서버를 멈춥니다.

```go
func (s *server) Stop() error {
    return nil
}
```

`Wait`은 서버가 새로운 연결을 받지 않고 대기하도록 합니다.

```go
func (s *server) Wait() error {
    return nil
}
```

```go
func main() {
```

새로운 `Server`를 생성합니다.

```go
    srv := NewServer("localhost")
```

API를 사용합니다.

```go
    srv.Start()
    srv.Stop()
    srv.Wait()
}
```

This code here couldn't care less nor would it change if `srv` was the concrete
type, not the interface. The interface is not providing any level of support
whatsoever. There is no decoupling here that is happening. It is not giving us
anything special here. All is doing is causing us another level of indirection.

It smells because:

- The package declares an interface that matches the entire API of its own
  concrete type.
- The interface is exported but the concrete type is unexported.
- The factory function returns the interface value with the unexported concrete
  type value inside.
- The interface can be removed and nothing changes for the user of the API.
- The interface is not decoupling the API from change.

##### 인터페이스 오염 제거

이전에 나온 예시에서 잘못된 인터페이스 사용을 고쳐보도록 하겠다.

`Server`의 구현이다.

```go
type Server struct {
    host string
}
```

`NewServer` 는 `Server`의 포인터를 반환한다.

```go
func NewServer(host string) *Server {
    return &Server{host}
}
```

`Start`가 호출되면 서버가 리퀘스트를 받기 시작한다.

```go
func (s *Server) Start() error {         
    return nil
}
```

`Stop`는 서버를 멈춘다.

```go
func (s *Server) Stop() error {
    return nil
}
```

`Wait`는 새로운 연결이 생성되는것을 막는다.

```go
func (s *Server) Wait() error {
    return nil
}
```

새로운 `Server`를 생성한다.

```go
func main() {
    srv := NewServer("localhost")
```

API를 사용한다.

```go
    srv.Start()
    srv.Stop()
    srv.Wait()
}
```

**인터페이스 오염을 피하기 위한 가이드라인**

인터페이스를 다음과 같은 상황에서 사용한다:

- 유저가 API의 실제 구현 디테일을 작성한다.
- API가 유지보수가 필요한 다양한 구현을 가지고 있다.
- API의 일부분이 변화할 수 있고 디커플링을 필요로 할때 사용한다.

다음과 같은 상황에서 인터페이스를 사용할지 다시 한번 생각해본다:

- 오직 테스트를 위해서만 사용한다.
- 변화로부터 쉽게 대응할 수 없다.
- 인터페이스가 코드를 더 좋게 만들어주지 않는다.

#### Mocking

##### Package To Mock

It is important to mock things. Most things over the network can be mocked in
our test. However, mocking our database is a different story because it is too
complex. This is where Docker can come in and simplify our code by allowing us
to launch our database while running our tests and have that clean database for
everything we do.

Every API only needs to focus on its test. We no longer have to worry about the
application user or user over API test. We used to worry about: if we don't
have that interface, the user who uses our API can't write tests. That is gone.
The example below will demonstrate the reason.

Imagine we are working at a company that decides to incorporate Go as a part of
its stack. They have their internal pubsub system that all applications are
supposed to use. Maybe they are doing event sourcing and there is a single
pubsub platform they are using that is not going to be replaced. They need the
pubsub API for Go that they can start building services that connect into this
event source.

So what can change? Can the event source change?

If the answer is no, then it immediately tells us that we don't need to use
interfaces. We can build the entire API in the concrete, which we would do
first anyway. We then write tests to make sure everything works.

A couple days later, they come to us with a problem. They have to write tests
and they cannot hit the pubsub system directly when my test runs so they need
to mock that out. They want us to give them an interface. However, we don't
need an interface because our API doesn't need an interface. They need an
interface, not us. They need to decouple from the pubsub system, not us.

They can do any decoupling they want because this is Go. The next file will be
an example of their application. Package pubsub simulates a package that
provides publication/subscription type services.

```go
package  main

import  (
    "fmt"
)
```

`PubSub` provides access to a queue system.

```go
type PubSub struct {
    host string
}
```

New creates a pubsub value for use.

```go
func New(host string) *PubSub {
    ps := PubSub{
        host: host,
    }

    return  &ps
}
```

Publish sends the data to the specified key.

```go
func (ps *PubSub) Publish(key string, v interface{}) error {
    fmt.Println("Actual PubSub: Publish")
    return nil
}
```

Subscribe sets up a request to receive messages from the specified key.

```go
func (ps *PubSub) Subscribe(key string) error {
    fmt.Println("Actual PubSub: Subscribe")
    return nil
}
```

##### Client

Sample program to show how we can personally mock concrete types when we need
to for our own packages or tests.

```go
package  main

import  (
    "fmt"
)
```

`publisher` is an interface to allow this package to mock the pubsub package.
When we are writing our applications, declare our own interface that maps out
all the APIs calls we need for the APIs. The concrete types APIs in the
previous files satisfy it out of the box. We can write the entire application
with mocking decoupling from concrete implementations.

```go
type publisher interface {
    Publish(key string, v interface{}) error
    Subscribe(key string) error
}
```

`mock` is a concrete type to help support the mocking of the pubsub package.

```go
type mock struct{}
```

`Publish` implements the `publisher` interface for the mock.

```go
func (m *mock) Publish(key string, v interface{}) error {
    // ADD YOUR MOCK FOR THE PUBLISH CALL.
    fmt.Println("Mock PubSub: Publish")
    return nil
}
```

`Subscribe` implements the `publisher` interface for the mock.

```go
func  (m *mock) Subscribe(key string) error {
    // ADD YOUR MOCK FOR THE SUBSCRIBE CALL.
    fmt.Println("Mock PubSub: Subscribe")
    return nil
}
```

Create a slice of `publisher` interface values. Assign the address of a pubsub.
`PubSub` value and the address of a mock value.

```go
func main() {
    pubs := []publisher{
        New("localhost"),
        &mock{},
    }
```

Range over the interface value to see how the publisher interface provides the
level of decoupling the user needs. The `pubsub` package did not need to provide
the interface type.

```go
    for _, p := range pubs {
        p.Publish("key", "value")
        p.Subscribe("key")
    }
}
```
